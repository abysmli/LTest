/* soapC.cpp
   Generated by gSOAP 2.8.10 from ltestgsoap.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.10 2012-11-19 12:58:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_SourceType:
		return soap_in_SourceType(soap, NULL, NULL, "SourceType");
	case SOAP_TYPE_proto_t:
		return soap_in_proto_t(soap, NULL, NULL, "proto-t");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns__ping:
		return soap_in_ns__ping(soap, NULL, NULL, "ns:ping");
	case SOAP_TYPE_ns__pingResponse:
		return soap_in_ns__pingResponse(soap, NULL, NULL, "ns:pingResponse");
	case SOAP_TYPE_PingResponse:
		return soap_in_PingResponse(soap, NULL, NULL, "PingResponse");
	case SOAP_TYPE_ns__print_sDesc:
		return soap_in_ns__print_sDesc(soap, NULL, NULL, "ns:print-sDesc");
	case SOAP_TYPE_ns__print_sDescResponse:
		return soap_in_ns__print_sDescResponse(soap, NULL, NULL, "ns:print-sDescResponse");
	case SOAP_TYPE_ns__start_ssession:
		return soap_in_ns__start_ssession(soap, NULL, NULL, "ns:start-ssession");
	case SOAP_TYPE_ns__start_ssessionResponse:
		return soap_in_ns__start_ssessionResponse(soap, NULL, NULL, "ns:start-ssessionResponse");
	case SOAP_TYPE_StartSSessionResponse:
		return soap_in_StartSSessionResponse(soap, NULL, NULL, "StartSSessionResponse");
	case SOAP_TYPE_ns__start_rsession:
		return soap_in_ns__start_rsession(soap, NULL, NULL, "ns:start-rsession");
	case SOAP_TYPE_ns__start_rsessionResponse:
		return soap_in_ns__start_rsessionResponse(soap, NULL, NULL, "ns:start-rsessionResponse");
	case SOAP_TYPE_StartRSessionResponse:
		return soap_in_StartRSessionResponse(soap, NULL, NULL, "StartRSessionResponse");
	case SOAP_TYPE_ns__release_UDP_time_port:
		return soap_in_ns__release_UDP_time_port(soap, NULL, NULL, "ns:release-UDP-time-port");
	case SOAP_TYPE_ns__release_UDP_time_portResponse:
		return soap_in_ns__release_UDP_time_portResponse(soap, NULL, NULL, "ns:release-UDP-time-portResponse");
	case SOAP_TYPE_ReleaseUDPTimePortResponse:
		return soap_in_ReleaseUDPTimePortResponse(soap, NULL, NULL, "ReleaseUDPTimePortResponse");
	case SOAP_TYPE_ns__start_UDP_time_port:
		return soap_in_ns__start_UDP_time_port(soap, NULL, NULL, "ns:start-UDP-time-port");
	case SOAP_TYPE_ns__start_UDP_time_portResponse:
		return soap_in_ns__start_UDP_time_portResponse(soap, NULL, NULL, "ns:start-UDP-time-portResponse");
	case SOAP_TYPE_ns__get_time_by_gsoap:
		return soap_in_ns__get_time_by_gsoap(soap, NULL, NULL, "ns:get-time-by-gsoap");
	case SOAP_TYPE_ns__get_time_by_gsoapResponse:
		return soap_in_ns__get_time_by_gsoapResponse(soap, NULL, NULL, "ns:get-time-by-gsoapResponse");
	case SOAP_TYPE_ns__finish_session:
		return soap_in_ns__finish_session(soap, NULL, NULL, "ns:finish-session");
	case SOAP_TYPE_ns__finish_sessionResponse:
		return soap_in_ns__finish_sessionResponse(soap, NULL, NULL, "ns:finish-sessionResponse");
	case SOAP_TYPE_FinishSessionResponse:
		return soap_in_FinishSessionResponse(soap, NULL, NULL, "FinishSessionResponse");
	case SOAP_TYPE_ns__get_samples:
		return soap_in_ns__get_samples(soap, NULL, NULL, "ns:get-samples");
	case SOAP_TYPE_ns__get_samplesResponse:
		return soap_in_ns__get_samplesResponse(soap, NULL, NULL, "ns:get-samplesResponse");
	case SOAP_TYPE_ns__getBasicSourceStats:
		return soap_in_ns__getBasicSourceStats(soap, NULL, NULL, "ns:getBasicSourceStats");
	case SOAP_TYPE_ns__getBasicSourceStatsResponse:
		return soap_in_ns__getBasicSourceStatsResponse(soap, NULL, NULL, "ns:getBasicSourceStatsResponse");
	case SOAP_TYPE_ns__get_samples_whole:
		return soap_in_ns__get_samples_whole(soap, NULL, NULL, "ns:get-samples-whole");
	case SOAP_TYPE_ns__get_samples_wholeResponse:
		return soap_in_ns__get_samples_wholeResponse(soap, NULL, NULL, "ns:get-samples-wholeResponse");
	case SOAP_TYPE_ns__release_rsession:
		return soap_in_ns__release_rsession(soap, NULL, NULL, "ns:release-rsession");
	case SOAP_TYPE_ns__release_rsessionResponse:
		return soap_in_ns__release_rsessionResponse(soap, NULL, NULL, "ns:release-rsessionResponse");
	case SOAP_TYPE_ReleaseRSessionResponse:
		return soap_in_ReleaseRSessionResponse(soap, NULL, NULL, "ReleaseRSessionResponse");
	case SOAP_TYPE_ns__release_ssession:
		return soap_in_ns__release_ssession(soap, NULL, NULL, "ns:release-ssession");
	case SOAP_TYPE_ns__release_ssessionResponse:
		return soap_in_ns__release_ssessionResponse(soap, NULL, NULL, "ns:release-ssessionResponse");
	case SOAP_TYPE_ReleaseSSessionResponse:
		return soap_in_ReleaseSSessionResponse(soap, NULL, NULL, "ReleaseSSessionResponse");
	case SOAP_TYPE_ns__Port:
		return soap_in_ns__Port(soap, NULL, NULL, "ns:Port");
	case SOAP_TYPE_ns__PortResponse:
		return soap_in_ns__PortResponse(soap, NULL, NULL, "ns:PortResponse");
	case SOAP_TYPE_BasicSourceStats_t:
		return soap_in_BasicSourceStats_t(soap, NULL, NULL, "BasicSourceStats-t");
	case SOAP_TYPE_senderDesc_t:
		return soap_in_senderDesc_t(soap, NULL, NULL, "senderDesc-t");
	case SOAP_TYPE_sourceDesc_t:
		return soap_in_sourceDesc_t(soap, NULL, NULL, "sourceDesc-t");
	case SOAP_TYPE_whole_sample_t:
		return soap_in_whole_sample_t(soap, NULL, NULL, "whole-sample-t");
	case SOAP_TYPE_sock_opt_t:
		return soap_in_sock_opt_t(soap, NULL, NULL, "sock-opt-t");
	case SOAP_TYPE_sample_t:
		return soap_in_sample_t(soap, NULL, NULL, "sample-t");
	case SOAP_TYPE_tv_type:
		return soap_in_tv_type(soap, NULL, NULL, "tv-type");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_Array24Ofbyte:
		return soap_in_Array24Ofbyte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_Array12Ofbyte:
		return soap_in_Array12Ofbyte(soap, NULL, NULL, "xsd:byte");
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SourceType"))
		{	*type = SOAP_TYPE_SourceType;
			return soap_in_SourceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "proto-t"))
		{	*type = SOAP_TYPE_proto_t;
			return soap_in_proto_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ping"))
		{	*type = SOAP_TYPE_ns__ping;
			return soap_in_ns__ping(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:pingResponse"))
		{	*type = SOAP_TYPE_ns__pingResponse;
			return soap_in_ns__pingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "PingResponse"))
		{	*type = SOAP_TYPE_PingResponse;
			return soap_in_PingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:print-sDesc"))
		{	*type = SOAP_TYPE_ns__print_sDesc;
			return soap_in_ns__print_sDesc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:print-sDescResponse"))
		{	*type = SOAP_TYPE_ns__print_sDescResponse;
			return soap_in_ns__print_sDescResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:start-ssession"))
		{	*type = SOAP_TYPE_ns__start_ssession;
			return soap_in_ns__start_ssession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:start-ssessionResponse"))
		{	*type = SOAP_TYPE_ns__start_ssessionResponse;
			return soap_in_ns__start_ssessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "StartSSessionResponse"))
		{	*type = SOAP_TYPE_StartSSessionResponse;
			return soap_in_StartSSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:start-rsession"))
		{	*type = SOAP_TYPE_ns__start_rsession;
			return soap_in_ns__start_rsession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:start-rsessionResponse"))
		{	*type = SOAP_TYPE_ns__start_rsessionResponse;
			return soap_in_ns__start_rsessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "StartRSessionResponse"))
		{	*type = SOAP_TYPE_StartRSessionResponse;
			return soap_in_StartRSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:release-UDP-time-port"))
		{	*type = SOAP_TYPE_ns__release_UDP_time_port;
			return soap_in_ns__release_UDP_time_port(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:release-UDP-time-portResponse"))
		{	*type = SOAP_TYPE_ns__release_UDP_time_portResponse;
			return soap_in_ns__release_UDP_time_portResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ReleaseUDPTimePortResponse"))
		{	*type = SOAP_TYPE_ReleaseUDPTimePortResponse;
			return soap_in_ReleaseUDPTimePortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:start-UDP-time-port"))
		{	*type = SOAP_TYPE_ns__start_UDP_time_port;
			return soap_in_ns__start_UDP_time_port(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:start-UDP-time-portResponse"))
		{	*type = SOAP_TYPE_ns__start_UDP_time_portResponse;
			return soap_in_ns__start_UDP_time_portResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-time-by-gsoap"))
		{	*type = SOAP_TYPE_ns__get_time_by_gsoap;
			return soap_in_ns__get_time_by_gsoap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-time-by-gsoapResponse"))
		{	*type = SOAP_TYPE_ns__get_time_by_gsoapResponse;
			return soap_in_ns__get_time_by_gsoapResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:finish-session"))
		{	*type = SOAP_TYPE_ns__finish_session;
			return soap_in_ns__finish_session(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:finish-sessionResponse"))
		{	*type = SOAP_TYPE_ns__finish_sessionResponse;
			return soap_in_ns__finish_sessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "FinishSessionResponse"))
		{	*type = SOAP_TYPE_FinishSessionResponse;
			return soap_in_FinishSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-samples"))
		{	*type = SOAP_TYPE_ns__get_samples;
			return soap_in_ns__get_samples(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-samplesResponse"))
		{	*type = SOAP_TYPE_ns__get_samplesResponse;
			return soap_in_ns__get_samplesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBasicSourceStats"))
		{	*type = SOAP_TYPE_ns__getBasicSourceStats;
			return soap_in_ns__getBasicSourceStats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:getBasicSourceStatsResponse"))
		{	*type = SOAP_TYPE_ns__getBasicSourceStatsResponse;
			return soap_in_ns__getBasicSourceStatsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-samples-whole"))
		{	*type = SOAP_TYPE_ns__get_samples_whole;
			return soap_in_ns__get_samples_whole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:get-samples-wholeResponse"))
		{	*type = SOAP_TYPE_ns__get_samples_wholeResponse;
			return soap_in_ns__get_samples_wholeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:release-rsession"))
		{	*type = SOAP_TYPE_ns__release_rsession;
			return soap_in_ns__release_rsession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:release-rsessionResponse"))
		{	*type = SOAP_TYPE_ns__release_rsessionResponse;
			return soap_in_ns__release_rsessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ReleaseRSessionResponse"))
		{	*type = SOAP_TYPE_ReleaseRSessionResponse;
			return soap_in_ReleaseRSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:release-ssession"))
		{	*type = SOAP_TYPE_ns__release_ssession;
			return soap_in_ns__release_ssession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:release-ssessionResponse"))
		{	*type = SOAP_TYPE_ns__release_ssessionResponse;
			return soap_in_ns__release_ssessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ReleaseSSessionResponse"))
		{	*type = SOAP_TYPE_ReleaseSSessionResponse;
			return soap_in_ReleaseSSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Port"))
		{	*type = SOAP_TYPE_ns__Port;
			return soap_in_ns__Port(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:PortResponse"))
		{	*type = SOAP_TYPE_ns__PortResponse;
			return soap_in_ns__PortResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "BasicSourceStats-t"))
		{	*type = SOAP_TYPE_BasicSourceStats_t;
			return soap_in_BasicSourceStats_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "senderDesc-t"))
		{	*type = SOAP_TYPE_senderDesc_t;
			return soap_in_senderDesc_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sourceDesc-t"))
		{	*type = SOAP_TYPE_sourceDesc_t;
			return soap_in_sourceDesc_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "whole-sample-t"))
		{	*type = SOAP_TYPE_whole_sample_t;
			return soap_in_whole_sample_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sock-opt-t"))
		{	*type = SOAP_TYPE_sock_opt_t;
			return soap_in_sock_opt_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "sample-t"))
		{	*type = SOAP_TYPE_sample_t;
			return soap_in_sample_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tv-type"))
		{	*type = SOAP_TYPE_tv_type;
			return soap_in_tv_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_Array24Ofbyte;
			return soap_in_Array24Ofbyte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_Array12Ofbyte;
			return soap_in_Array12Ofbyte(soap, NULL, NULL, NULL);
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_SourceType:
		return soap_out_SourceType(soap, tag, id, (const enum SourceType *)ptr, "SourceType");
	case SOAP_TYPE_proto_t:
		return soap_out_proto_t(soap, tag, id, (const enum proto_t *)ptr, "proto-t");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns__ping:
		return soap_out_ns__ping(soap, tag, id, (const struct ns__ping *)ptr, "ns:ping");
	case SOAP_TYPE_ns__pingResponse:
		return soap_out_ns__pingResponse(soap, tag, id, (const struct ns__pingResponse *)ptr, "ns:pingResponse");
	case SOAP_TYPE_PingResponse:
		return soap_out_PingResponse(soap, tag, id, (const struct PingResponse *)ptr, "PingResponse");
	case SOAP_TYPE_ns__print_sDesc:
		return soap_out_ns__print_sDesc(soap, tag, id, (const struct ns__print_sDesc *)ptr, "ns:print-sDesc");
	case SOAP_TYPE_ns__print_sDescResponse:
		return soap_out_ns__print_sDescResponse(soap, tag, id, (const struct ns__print_sDescResponse *)ptr, "ns:print-sDescResponse");
	case SOAP_TYPE_ns__start_ssession:
		return soap_out_ns__start_ssession(soap, tag, id, (const struct ns__start_ssession *)ptr, "ns:start-ssession");
	case SOAP_TYPE_ns__start_ssessionResponse:
		return soap_out_ns__start_ssessionResponse(soap, tag, id, (const struct ns__start_ssessionResponse *)ptr, "ns:start-ssessionResponse");
	case SOAP_TYPE_StartSSessionResponse:
		return soap_out_StartSSessionResponse(soap, tag, id, (const struct StartSSessionResponse *)ptr, "StartSSessionResponse");
	case SOAP_TYPE_ns__start_rsession:
		return soap_out_ns__start_rsession(soap, tag, id, (const struct ns__start_rsession *)ptr, "ns:start-rsession");
	case SOAP_TYPE_ns__start_rsessionResponse:
		return soap_out_ns__start_rsessionResponse(soap, tag, id, (const struct ns__start_rsessionResponse *)ptr, "ns:start-rsessionResponse");
	case SOAP_TYPE_StartRSessionResponse:
		return soap_out_StartRSessionResponse(soap, tag, id, (const struct StartRSessionResponse *)ptr, "StartRSessionResponse");
	case SOAP_TYPE_ns__release_UDP_time_port:
		return soap_out_ns__release_UDP_time_port(soap, tag, id, (const struct ns__release_UDP_time_port *)ptr, "ns:release-UDP-time-port");
	case SOAP_TYPE_ns__release_UDP_time_portResponse:
		return soap_out_ns__release_UDP_time_portResponse(soap, tag, id, (const struct ns__release_UDP_time_portResponse *)ptr, "ns:release-UDP-time-portResponse");
	case SOAP_TYPE_ReleaseUDPTimePortResponse:
		return soap_out_ReleaseUDPTimePortResponse(soap, tag, id, (const struct ReleaseUDPTimePortResponse *)ptr, "ReleaseUDPTimePortResponse");
	case SOAP_TYPE_ns__start_UDP_time_port:
		return soap_out_ns__start_UDP_time_port(soap, tag, id, (const struct ns__start_UDP_time_port *)ptr, "ns:start-UDP-time-port");
	case SOAP_TYPE_ns__start_UDP_time_portResponse:
		return soap_out_ns__start_UDP_time_portResponse(soap, tag, id, (const struct ns__start_UDP_time_portResponse *)ptr, "ns:start-UDP-time-portResponse");
	case SOAP_TYPE_ns__get_time_by_gsoap:
		return soap_out_ns__get_time_by_gsoap(soap, tag, id, (const struct ns__get_time_by_gsoap *)ptr, "ns:get-time-by-gsoap");
	case SOAP_TYPE_ns__get_time_by_gsoapResponse:
		return soap_out_ns__get_time_by_gsoapResponse(soap, tag, id, (const struct ns__get_time_by_gsoapResponse *)ptr, "ns:get-time-by-gsoapResponse");
	case SOAP_TYPE_ns__finish_session:
		return soap_out_ns__finish_session(soap, tag, id, (const struct ns__finish_session *)ptr, "ns:finish-session");
	case SOAP_TYPE_ns__finish_sessionResponse:
		return soap_out_ns__finish_sessionResponse(soap, tag, id, (const struct ns__finish_sessionResponse *)ptr, "ns:finish-sessionResponse");
	case SOAP_TYPE_FinishSessionResponse:
		return soap_out_FinishSessionResponse(soap, tag, id, (const struct FinishSessionResponse *)ptr, "FinishSessionResponse");
	case SOAP_TYPE_ns__get_samples:
		return soap_out_ns__get_samples(soap, tag, id, (const struct ns__get_samples *)ptr, "ns:get-samples");
	case SOAP_TYPE_ns__get_samplesResponse:
		return soap_out_ns__get_samplesResponse(soap, tag, id, (const struct ns__get_samplesResponse *)ptr, "ns:get-samplesResponse");
	case SOAP_TYPE_ns__getBasicSourceStats:
		return soap_out_ns__getBasicSourceStats(soap, tag, id, (const struct ns__getBasicSourceStats *)ptr, "ns:getBasicSourceStats");
	case SOAP_TYPE_ns__getBasicSourceStatsResponse:
		return soap_out_ns__getBasicSourceStatsResponse(soap, tag, id, (const struct ns__getBasicSourceStatsResponse *)ptr, "ns:getBasicSourceStatsResponse");
	case SOAP_TYPE_ns__get_samples_whole:
		return soap_out_ns__get_samples_whole(soap, tag, id, (const struct ns__get_samples_whole *)ptr, "ns:get-samples-whole");
	case SOAP_TYPE_ns__get_samples_wholeResponse:
		return soap_out_ns__get_samples_wholeResponse(soap, tag, id, (const struct ns__get_samples_wholeResponse *)ptr, "ns:get-samples-wholeResponse");
	case SOAP_TYPE_ns__release_rsession:
		return soap_out_ns__release_rsession(soap, tag, id, (const struct ns__release_rsession *)ptr, "ns:release-rsession");
	case SOAP_TYPE_ns__release_rsessionResponse:
		return soap_out_ns__release_rsessionResponse(soap, tag, id, (const struct ns__release_rsessionResponse *)ptr, "ns:release-rsessionResponse");
	case SOAP_TYPE_ReleaseRSessionResponse:
		return soap_out_ReleaseRSessionResponse(soap, tag, id, (const struct ReleaseRSessionResponse *)ptr, "ReleaseRSessionResponse");
	case SOAP_TYPE_ns__release_ssession:
		return soap_out_ns__release_ssession(soap, tag, id, (const struct ns__release_ssession *)ptr, "ns:release-ssession");
	case SOAP_TYPE_ns__release_ssessionResponse:
		return soap_out_ns__release_ssessionResponse(soap, tag, id, (const struct ns__release_ssessionResponse *)ptr, "ns:release-ssessionResponse");
	case SOAP_TYPE_ReleaseSSessionResponse:
		return soap_out_ReleaseSSessionResponse(soap, tag, id, (const struct ReleaseSSessionResponse *)ptr, "ReleaseSSessionResponse");
	case SOAP_TYPE_ns__Port:
		return soap_out_ns__Port(soap, tag, id, (const struct ns__Port *)ptr, "ns:Port");
	case SOAP_TYPE_ns__PortResponse:
		return soap_out_ns__PortResponse(soap, tag, id, (const struct ns__PortResponse *)ptr, "ns:PortResponse");
	case SOAP_TYPE_BasicSourceStats_t:
		return soap_out_BasicSourceStats_t(soap, tag, id, (const struct BasicSourceStats_t *)ptr, "BasicSourceStats-t");
	case SOAP_TYPE_senderDesc_t:
		return soap_out_senderDesc_t(soap, tag, id, (const struct senderDesc_t *)ptr, "senderDesc-t");
	case SOAP_TYPE_sourceDesc_t:
		return soap_out_sourceDesc_t(soap, tag, id, (const struct sourceDesc_t *)ptr, "sourceDesc-t");
	case SOAP_TYPE_whole_sample_t:
		return soap_out_whole_sample_t(soap, tag, id, (const struct whole_sample_t *)ptr, "whole-sample-t");
	case SOAP_TYPE_sock_opt_t:
		return soap_out_sock_opt_t(soap, tag, id, (const struct sock_opt_t *)ptr, "sock-opt-t");
	case SOAP_TYPE_sample_t:
		return soap_out_sample_t(soap, tag, id, (const struct sample_t *)ptr, "sample-t");
	case SOAP_TYPE_tv_type:
		return soap_out_tv_type(soap, tag, id, (const struct tv_type *)ptr, "tv-type");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	case SOAP_TYPE_Array24Ofbyte:
		return soap_out_Array24Ofbyte(soap, tag, id, (char (*))ptr, "xsd:byte");
	case SOAP_TYPE_Array12Ofbyte:
		return soap_out_Array12Ofbyte(soap, tag, id, (char (*))ptr, "xsd:byte");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns__ping:
		soap_serialize_ns__ping(soap, (const struct ns__ping *)ptr);
		break;
	case SOAP_TYPE_ns__pingResponse:
		soap_serialize_ns__pingResponse(soap, (const struct ns__pingResponse *)ptr);
		break;
	case SOAP_TYPE_PingResponse:
		soap_serialize_PingResponse(soap, (const struct PingResponse *)ptr);
		break;
	case SOAP_TYPE_ns__print_sDesc:
		soap_serialize_ns__print_sDesc(soap, (const struct ns__print_sDesc *)ptr);
		break;
	case SOAP_TYPE_ns__print_sDescResponse:
		soap_serialize_ns__print_sDescResponse(soap, (const struct ns__print_sDescResponse *)ptr);
		break;
	case SOAP_TYPE_ns__start_ssession:
		soap_serialize_ns__start_ssession(soap, (const struct ns__start_ssession *)ptr);
		break;
	case SOAP_TYPE_ns__start_ssessionResponse:
		soap_serialize_ns__start_ssessionResponse(soap, (const struct ns__start_ssessionResponse *)ptr);
		break;
	case SOAP_TYPE_StartSSessionResponse:
		soap_serialize_StartSSessionResponse(soap, (const struct StartSSessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns__start_rsession:
		soap_serialize_ns__start_rsession(soap, (const struct ns__start_rsession *)ptr);
		break;
	case SOAP_TYPE_ns__start_rsessionResponse:
		soap_serialize_ns__start_rsessionResponse(soap, (const struct ns__start_rsessionResponse *)ptr);
		break;
	case SOAP_TYPE_StartRSessionResponse:
		soap_serialize_StartRSessionResponse(soap, (const struct StartRSessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns__release_UDP_time_port:
		soap_serialize_ns__release_UDP_time_port(soap, (const struct ns__release_UDP_time_port *)ptr);
		break;
	case SOAP_TYPE_ns__release_UDP_time_portResponse:
		soap_serialize_ns__release_UDP_time_portResponse(soap, (const struct ns__release_UDP_time_portResponse *)ptr);
		break;
	case SOAP_TYPE_ReleaseUDPTimePortResponse:
		soap_serialize_ReleaseUDPTimePortResponse(soap, (const struct ReleaseUDPTimePortResponse *)ptr);
		break;
	case SOAP_TYPE_ns__start_UDP_time_port:
		soap_serialize_ns__start_UDP_time_port(soap, (const struct ns__start_UDP_time_port *)ptr);
		break;
	case SOAP_TYPE_ns__start_UDP_time_portResponse:
		soap_serialize_ns__start_UDP_time_portResponse(soap, (const struct ns__start_UDP_time_portResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_time_by_gsoap:
		soap_serialize_ns__get_time_by_gsoap(soap, (const struct ns__get_time_by_gsoap *)ptr);
		break;
	case SOAP_TYPE_ns__get_time_by_gsoapResponse:
		soap_serialize_ns__get_time_by_gsoapResponse(soap, (const struct ns__get_time_by_gsoapResponse *)ptr);
		break;
	case SOAP_TYPE_ns__finish_session:
		soap_serialize_ns__finish_session(soap, (const struct ns__finish_session *)ptr);
		break;
	case SOAP_TYPE_ns__finish_sessionResponse:
		soap_serialize_ns__finish_sessionResponse(soap, (const struct ns__finish_sessionResponse *)ptr);
		break;
	case SOAP_TYPE_FinishSessionResponse:
		soap_serialize_FinishSessionResponse(soap, (const struct FinishSessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_samples:
		soap_serialize_ns__get_samples(soap, (const struct ns__get_samples *)ptr);
		break;
	case SOAP_TYPE_ns__get_samplesResponse:
		soap_serialize_ns__get_samplesResponse(soap, (const struct ns__get_samplesResponse *)ptr);
		break;
	case SOAP_TYPE_ns__getBasicSourceStats:
		soap_serialize_ns__getBasicSourceStats(soap, (const struct ns__getBasicSourceStats *)ptr);
		break;
	case SOAP_TYPE_ns__getBasicSourceStatsResponse:
		soap_serialize_ns__getBasicSourceStatsResponse(soap, (const struct ns__getBasicSourceStatsResponse *)ptr);
		break;
	case SOAP_TYPE_ns__get_samples_whole:
		soap_serialize_ns__get_samples_whole(soap, (const struct ns__get_samples_whole *)ptr);
		break;
	case SOAP_TYPE_ns__get_samples_wholeResponse:
		soap_serialize_ns__get_samples_wholeResponse(soap, (const struct ns__get_samples_wholeResponse *)ptr);
		break;
	case SOAP_TYPE_ns__release_rsession:
		soap_serialize_ns__release_rsession(soap, (const struct ns__release_rsession *)ptr);
		break;
	case SOAP_TYPE_ns__release_rsessionResponse:
		soap_serialize_ns__release_rsessionResponse(soap, (const struct ns__release_rsessionResponse *)ptr);
		break;
	case SOAP_TYPE_ReleaseRSessionResponse:
		soap_serialize_ReleaseRSessionResponse(soap, (const struct ReleaseRSessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns__release_ssession:
		soap_serialize_ns__release_ssession(soap, (const struct ns__release_ssession *)ptr);
		break;
	case SOAP_TYPE_ns__release_ssessionResponse:
		soap_serialize_ns__release_ssessionResponse(soap, (const struct ns__release_ssessionResponse *)ptr);
		break;
	case SOAP_TYPE_ReleaseSSessionResponse:
		soap_serialize_ReleaseSSessionResponse(soap, (const struct ReleaseSSessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns__Port:
		soap_serialize_ns__Port(soap, (const struct ns__Port *)ptr);
		break;
	case SOAP_TYPE_ns__PortResponse:
		soap_serialize_ns__PortResponse(soap, (const struct ns__PortResponse *)ptr);
		break;
	case SOAP_TYPE_BasicSourceStats_t:
		soap_serialize_BasicSourceStats_t(soap, (const struct BasicSourceStats_t *)ptr);
		break;
	case SOAP_TYPE_senderDesc_t:
		soap_serialize_senderDesc_t(soap, (const struct senderDesc_t *)ptr);
		break;
	case SOAP_TYPE_sourceDesc_t:
		soap_serialize_sourceDesc_t(soap, (const struct sourceDesc_t *)ptr);
		break;
	case SOAP_TYPE_whole_sample_t:
		soap_serialize_whole_sample_t(soap, (const struct whole_sample_t *)ptr);
		break;
	case SOAP_TYPE_sock_opt_t:
		soap_serialize_sock_opt_t(soap, (const struct sock_opt_t *)ptr);
		break;
	case SOAP_TYPE_sample_t:
		soap_serialize_sample_t(soap, (const struct sample_t *)ptr);
		break;
	case SOAP_TYPE_tv_type:
		soap_serialize_tv_type(soap, (const struct tv_type *)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_Array24Ofbyte:
		soap_serialize_Array24Ofbyte(soap, (char (*))ptr);
		break;
	case SOAP_TYPE_Array12Ofbyte:
		soap_serialize_Array12Ofbyte(soap, (char (*))ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_tv_type:
		return (void*)soap_instantiate_tv_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sample_t:
		return (void*)soap_instantiate_sample_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sock_opt_t:
		return (void*)soap_instantiate_sock_opt_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_whole_sample_t:
		return (void*)soap_instantiate_whole_sample_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sourceDesc_t:
		return (void*)soap_instantiate_sourceDesc_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_senderDesc_t:
		return (void*)soap_instantiate_senderDesc_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_BasicSourceStats_t:
		return (void*)soap_instantiate_BasicSourceStats_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__PortResponse:
		return (void*)soap_instantiate_ns__PortResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Port:
		return (void*)soap_instantiate_ns__Port(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ReleaseSSessionResponse:
		return (void*)soap_instantiate_ReleaseSSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__release_ssessionResponse:
		return (void*)soap_instantiate_ns__release_ssessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__release_ssession:
		return (void*)soap_instantiate_ns__release_ssession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ReleaseRSessionResponse:
		return (void*)soap_instantiate_ReleaseRSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__release_rsessionResponse:
		return (void*)soap_instantiate_ns__release_rsessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__release_rsession:
		return (void*)soap_instantiate_ns__release_rsession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_samples_wholeResponse:
		return (void*)soap_instantiate_ns__get_samples_wholeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_samples_whole:
		return (void*)soap_instantiate_ns__get_samples_whole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getBasicSourceStatsResponse:
		return (void*)soap_instantiate_ns__getBasicSourceStatsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__getBasicSourceStats:
		return (void*)soap_instantiate_ns__getBasicSourceStats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_samplesResponse:
		return (void*)soap_instantiate_ns__get_samplesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_samples:
		return (void*)soap_instantiate_ns__get_samples(soap, -1, type, arrayType, n);
	case SOAP_TYPE_FinishSessionResponse:
		return (void*)soap_instantiate_FinishSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__finish_sessionResponse:
		return (void*)soap_instantiate_ns__finish_sessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__finish_session:
		return (void*)soap_instantiate_ns__finish_session(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_time_by_gsoapResponse:
		return (void*)soap_instantiate_ns__get_time_by_gsoapResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__get_time_by_gsoap:
		return (void*)soap_instantiate_ns__get_time_by_gsoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__start_UDP_time_portResponse:
		return (void*)soap_instantiate_ns__start_UDP_time_portResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__start_UDP_time_port:
		return (void*)soap_instantiate_ns__start_UDP_time_port(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ReleaseUDPTimePortResponse:
		return (void*)soap_instantiate_ReleaseUDPTimePortResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__release_UDP_time_portResponse:
		return (void*)soap_instantiate_ns__release_UDP_time_portResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__release_UDP_time_port:
		return (void*)soap_instantiate_ns__release_UDP_time_port(soap, -1, type, arrayType, n);
	case SOAP_TYPE_StartRSessionResponse:
		return (void*)soap_instantiate_StartRSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__start_rsessionResponse:
		return (void*)soap_instantiate_ns__start_rsessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__start_rsession:
		return (void*)soap_instantiate_ns__start_rsession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_StartSSessionResponse:
		return (void*)soap_instantiate_StartSSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__start_ssessionResponse:
		return (void*)soap_instantiate_ns__start_ssessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__start_ssession:
		return (void*)soap_instantiate_ns__start_ssession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__print_sDescResponse:
		return (void*)soap_instantiate_ns__print_sDescResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__print_sDesc:
		return (void*)soap_instantiate_ns__print_sDesc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_PingResponse:
		return (void*)soap_instantiate_PingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__pingResponse:
		return (void*)soap_instantiate_ns__pingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ping:
		return (void*)soap_instantiate_ns__ping(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfsample_t:
		return (void*)soap_instantiate_std__vectorTemplateOfsample_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwhole_sample_t:
		return (void*)soap_instantiate_std__vectorTemplateOfwhole_sample_t(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfsock_opt_t:
		return (void*)soap_instantiate_std__vectorTemplateOfsock_opt_t(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_tv_type:
		if (p->size < 0)
			SOAP_DELETE((struct tv_type*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct tv_type*)p->ptr);
		break;
	case SOAP_TYPE_sample_t:
		if (p->size < 0)
			SOAP_DELETE((struct sample_t*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct sample_t*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_sock_opt_t:
		if (p->size < 0)
			SOAP_DELETE((struct sock_opt_t*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct sock_opt_t*)p->ptr);
		break;
	case SOAP_TYPE_whole_sample_t:
		if (p->size < 0)
			SOAP_DELETE((struct whole_sample_t*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct whole_sample_t*)p->ptr);
		break;
	case SOAP_TYPE_sourceDesc_t:
		if (p->size < 0)
			SOAP_DELETE((struct sourceDesc_t*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct sourceDesc_t*)p->ptr);
		break;
	case SOAP_TYPE_senderDesc_t:
		if (p->size < 0)
			SOAP_DELETE((struct senderDesc_t*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct senderDesc_t*)p->ptr);
		break;
	case SOAP_TYPE_BasicSourceStats_t:
		if (p->size < 0)
			SOAP_DELETE((struct BasicSourceStats_t*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct BasicSourceStats_t*)p->ptr);
		break;
	case SOAP_TYPE_ns__PortResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__PortResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__PortResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__Port:
		if (p->size < 0)
			SOAP_DELETE((struct ns__Port*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__Port*)p->ptr);
		break;
	case SOAP_TYPE_ReleaseSSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ReleaseSSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReleaseSSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__release_ssessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__release_ssessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__release_ssessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__release_ssession:
		if (p->size < 0)
			SOAP_DELETE((struct ns__release_ssession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__release_ssession*)p->ptr);
		break;
	case SOAP_TYPE_ReleaseRSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ReleaseRSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReleaseRSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__release_rsessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__release_rsessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__release_rsessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__release_rsession:
		if (p->size < 0)
			SOAP_DELETE((struct ns__release_rsession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__release_rsession*)p->ptr);
		break;
	case SOAP_TYPE_ns__get_samples_wholeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__get_samples_wholeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__get_samples_wholeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__get_samples_whole:
		if (p->size < 0)
			SOAP_DELETE((struct ns__get_samples_whole*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__get_samples_whole*)p->ptr);
		break;
	case SOAP_TYPE_ns__getBasicSourceStatsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__getBasicSourceStatsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__getBasicSourceStatsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__getBasicSourceStats:
		if (p->size < 0)
			SOAP_DELETE((struct ns__getBasicSourceStats*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__getBasicSourceStats*)p->ptr);
		break;
	case SOAP_TYPE_ns__get_samplesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__get_samplesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__get_samplesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__get_samples:
		if (p->size < 0)
			SOAP_DELETE((struct ns__get_samples*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__get_samples*)p->ptr);
		break;
	case SOAP_TYPE_FinishSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct FinishSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct FinishSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__finish_sessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__finish_sessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__finish_sessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__finish_session:
		if (p->size < 0)
			SOAP_DELETE((struct ns__finish_session*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__finish_session*)p->ptr);
		break;
	case SOAP_TYPE_ns__get_time_by_gsoapResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__get_time_by_gsoapResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__get_time_by_gsoapResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__get_time_by_gsoap:
		if (p->size < 0)
			SOAP_DELETE((struct ns__get_time_by_gsoap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__get_time_by_gsoap*)p->ptr);
		break;
	case SOAP_TYPE_ns__start_UDP_time_portResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__start_UDP_time_portResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__start_UDP_time_portResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__start_UDP_time_port:
		if (p->size < 0)
			SOAP_DELETE((struct ns__start_UDP_time_port*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__start_UDP_time_port*)p->ptr);
		break;
	case SOAP_TYPE_ReleaseUDPTimePortResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ReleaseUDPTimePortResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ReleaseUDPTimePortResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__release_UDP_time_portResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__release_UDP_time_portResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__release_UDP_time_portResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__release_UDP_time_port:
		if (p->size < 0)
			SOAP_DELETE((struct ns__release_UDP_time_port*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__release_UDP_time_port*)p->ptr);
		break;
	case SOAP_TYPE_StartRSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct StartRSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct StartRSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__start_rsessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__start_rsessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__start_rsessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__start_rsession:
		if (p->size < 0)
			SOAP_DELETE((struct ns__start_rsession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__start_rsession*)p->ptr);
		break;
	case SOAP_TYPE_StartSSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct StartSSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct StartSSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__start_ssessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__start_ssessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__start_ssessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__start_ssession:
		if (p->size < 0)
			SOAP_DELETE((struct ns__start_ssession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__start_ssession*)p->ptr);
		break;
	case SOAP_TYPE_ns__print_sDescResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__print_sDescResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__print_sDescResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__print_sDesc:
		if (p->size < 0)
			SOAP_DELETE((struct ns__print_sDesc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__print_sDesc*)p->ptr);
		break;
	case SOAP_TYPE_PingResponse:
		if (p->size < 0)
			SOAP_DELETE((struct PingResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct PingResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__pingResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns__pingResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__pingResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns__ping:
		if (p->size < 0)
			SOAP_DELETE((struct ns__ping*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns__ping*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfsample_t:
		if (p->size < 0)
			SOAP_DELETE((std::vector<struct sample_t >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<struct sample_t >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfwhole_sample_t:
		if (p->size < 0)
			SOAP_DELETE((std::vector<struct whole_sample_t >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<struct whole_sample_t >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfsock_opt_t:
		if (p->size < 0)
			SOAP_DELETE((std::vector<struct sock_opt_t >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<struct sock_opt_t >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfsample_t:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<struct sample_t >*)p)[len] = *(struct sample_t *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfwhole_sample_t:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<struct whole_sample_t >*)p)[len] = *(struct whole_sample_t *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfsock_opt_t:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<struct sock_opt_t >*)p)[len] = *(struct sock_opt_t *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{	long *p;
	p = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{	unsigned short *p;
	p = soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag?tag:"unsignedShort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{	unsigned long *p;
	p = soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SourceType(struct soap *soap, enum SourceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_SourceType
	*a = SOAP_DEFAULT_SourceType;
#else
	*a = (enum SourceType)0;
#endif
}

static const struct soap_code_map soap_codes_SourceType[] =
{	{ (long)ST_CBR, "ST-CBR" },
	{ (long)ST_POISSON, "ST-POISSON" },
	{ (long)ST_FIFO, "ST-FIFO" },
	{ (long)ST_FS, "ST-FS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_SourceType2s(struct soap *soap, enum SourceType n)
{	const char *s = soap_code_str(soap_codes_SourceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SourceType(struct soap *soap, const char *tag, int id, const enum SourceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SourceType), type) || soap_send(soap, soap_SourceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2SourceType(struct soap *soap, const char *s, enum SourceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_SourceType, s);
	if (map)
		*a = (enum SourceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum SourceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum SourceType * SOAP_FMAC4 soap_in_SourceType(struct soap *soap, const char *tag, enum SourceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum SourceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SourceType, sizeof(enum SourceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2SourceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum SourceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SourceType, 0, sizeof(enum SourceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SourceType(struct soap *soap, const enum SourceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SourceType);
	if (soap_out_SourceType(soap, tag?tag:"SourceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum SourceType * SOAP_FMAC4 soap_get_SourceType(struct soap *soap, enum SourceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_SourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_proto_t(struct soap *soap, enum proto_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_proto_t
	*a = SOAP_DEFAULT_proto_t;
#else
	*a = (enum proto_t)0;
#endif
}

static const struct soap_code_map soap_codes_proto_t[] =
{	{ (long)P_TCP, "P-TCP" },
	{ (long)P_UDP, "P-UDP" },
	{ (long)P_SDP, "P-SDP" },
	{ (long)P_UDT, "P-UDT" },
	{ (long)P_FastTCP, "P-FastTCP" },
	{ (long)P_HSTCP, "P-HSTCP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_proto_t2s(struct soap *soap, enum proto_t n)
{	const char *s = soap_code_str(soap_codes_proto_t, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_proto_t(struct soap *soap, const char *tag, int id, const enum proto_t *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_proto_t), type) || soap_send(soap, soap_proto_t2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2proto_t(struct soap *soap, const char *s, enum proto_t *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_proto_t, s);
	if (map)
		*a = (enum proto_t)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum proto_t)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum proto_t * SOAP_FMAC4 soap_in_proto_t(struct soap *soap, const char *tag, enum proto_t *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum proto_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_proto_t, sizeof(enum proto_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2proto_t(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum proto_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_proto_t, 0, sizeof(enum proto_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_proto_t(struct soap *soap, const enum proto_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_proto_t);
	if (soap_out_proto_t(soap, tag?tag:"proto-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum proto_t * SOAP_FMAC4 soap_get_proto_t(struct soap *soap, enum proto_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_proto_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ping(struct soap *soap, struct ns__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ping(struct soap *soap, const struct ns__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ping(struct soap *soap, const char *tag, int id, const struct ns__ping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ping), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ping * SOAP_FMAC4 soap_in_ns__ping(struct soap *soap, const char *tag, struct ns__ping *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ping *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ping, sizeof(struct ns__ping), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__ping(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__ping *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ping, 0, sizeof(struct ns__ping), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ping(struct soap *soap, const struct ns__ping *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__ping);
	if (soap_out_ns__ping(soap, tag?tag:"ns:ping", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__ping * SOAP_FMAC4 soap_get_ns__ping(struct soap *soap, struct ns__ping *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__ping * SOAP_FMAC2 soap_instantiate_ns__ping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ping(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__ping, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__ping);
		if (size)
			*size = sizeof(struct ns__ping);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__ping[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__ping);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__ping*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__ping(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__ping %p -> %p\n", q, p));
	*(struct ns__ping*)p = *(struct ns__ping*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__pingResponse(struct soap *soap, struct ns__pingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_PingResponse(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__pingResponse(struct soap *soap, const struct ns__pingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PingResponse(soap, &a->response);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__pingResponse(struct soap *soap, const char *tag, int id, const struct ns__pingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__pingResponse), type))
		return soap->error;
	if (soap_out_PingResponse(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__pingResponse * SOAP_FMAC4 soap_in_ns__pingResponse(struct soap *soap, const char *tag, struct ns__pingResponse *a, const char *type)
{
	size_t soap_flag_response = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__pingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__pingResponse, sizeof(struct ns__pingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__pingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PingResponse(soap, "response", &a->response, "PingResponse"))
				{	soap_flag_response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__pingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__pingResponse, 0, sizeof(struct ns__pingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__pingResponse(struct soap *soap, const struct ns__pingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__pingResponse);
	if (soap_out_ns__pingResponse(soap, tag?tag:"ns:pingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__pingResponse * SOAP_FMAC4 soap_get_ns__pingResponse(struct soap *soap, struct ns__pingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__pingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__pingResponse * SOAP_FMAC2 soap_instantiate_ns__pingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__pingResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__pingResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__pingResponse);
		if (size)
			*size = sizeof(struct ns__pingResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__pingResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__pingResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__pingResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__pingResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__pingResponse %p -> %p\n", q, p));
	*(struct ns__pingResponse*)p = *(struct ns__pingResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PingResponse(struct soap *soap, struct PingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PingResponse(struct soap *soap, const struct PingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PingResponse(struct soap *soap, const char *tag, int id, const struct PingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_PingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct PingResponse * SOAP_FMAC4 soap_in_PingResponse(struct soap *soap, const char *tag, struct PingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct PingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PingResponse, sizeof(struct PingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_PingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct PingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_PingResponse, 0, sizeof(struct PingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PingResponse(struct soap *soap, const struct PingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PingResponse);
	if (soap_out_PingResponse(soap, tag?tag:"PingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct PingResponse * SOAP_FMAC4 soap_get_PingResponse(struct soap *soap, struct PingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_PingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct PingResponse * SOAP_FMAC2 soap_instantiate_PingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_PingResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_PingResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct PingResponse);
		if (size)
			*size = sizeof(struct PingResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct PingResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct PingResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct PingResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_PingResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct PingResponse %p -> %p\n", q, p));
	*(struct PingResponse*)p = *(struct PingResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__print_sDesc(struct soap *soap, struct ns__print_sDesc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_sourceDesc_t(soap, &a->sDec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__print_sDesc(struct soap *soap, const struct ns__print_sDesc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_sourceDesc_t(soap, &a->sDec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__print_sDesc(struct soap *soap, const char *tag, int id, const struct ns__print_sDesc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__print_sDesc), type))
		return soap->error;
	if (soap_out_sourceDesc_t(soap, "sDec", -1, &a->sDec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__print_sDesc * SOAP_FMAC4 soap_in_ns__print_sDesc(struct soap *soap, const char *tag, struct ns__print_sDesc *a, const char *type)
{
	size_t soap_flag_sDec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__print_sDesc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__print_sDesc, sizeof(struct ns__print_sDesc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__print_sDesc(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sDec && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_sourceDesc_t(soap, "sDec", &a->sDec, "sourceDesc-t"))
				{	soap_flag_sDec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__print_sDesc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__print_sDesc, 0, sizeof(struct ns__print_sDesc), 0, soap_copy_ns__print_sDesc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sDec > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__print_sDesc(struct soap *soap, const struct ns__print_sDesc *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__print_sDesc);
	if (soap_out_ns__print_sDesc(soap, tag?tag:"ns:print-sDesc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__print_sDesc * SOAP_FMAC4 soap_get_ns__print_sDesc(struct soap *soap, struct ns__print_sDesc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__print_sDesc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__print_sDesc * SOAP_FMAC2 soap_instantiate_ns__print_sDesc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__print_sDesc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__print_sDesc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__print_sDesc);
		if (size)
			*size = sizeof(struct ns__print_sDesc);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__print_sDesc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__print_sDesc);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__print_sDesc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__print_sDesc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__print_sDesc %p -> %p\n", q, p));
	*(struct ns__print_sDesc*)p = *(struct ns__print_sDesc*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__print_sDescResponse(struct soap *soap, struct ns__print_sDescResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->str);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__print_sDescResponse(struct soap *soap, const struct ns__print_sDescResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->str);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__print_sDescResponse(struct soap *soap, const char *tag, int id, const struct ns__print_sDescResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__print_sDescResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "str", -1, &a->str, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__print_sDescResponse * SOAP_FMAC4 soap_in_ns__print_sDescResponse(struct soap *soap, const char *tag, struct ns__print_sDescResponse *a, const char *type)
{
	size_t soap_flag_str = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__print_sDescResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__print_sDescResponse, sizeof(struct ns__print_sDescResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__print_sDescResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_str && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "str", &a->str, "xsd:string"))
				{	soap_flag_str--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__print_sDescResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__print_sDescResponse, 0, sizeof(struct ns__print_sDescResponse), 0, soap_copy_ns__print_sDescResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_str > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__print_sDescResponse(struct soap *soap, const struct ns__print_sDescResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__print_sDescResponse);
	if (soap_out_ns__print_sDescResponse(soap, tag?tag:"ns:print-sDescResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__print_sDescResponse * SOAP_FMAC4 soap_get_ns__print_sDescResponse(struct soap *soap, struct ns__print_sDescResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__print_sDescResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__print_sDescResponse * SOAP_FMAC2 soap_instantiate_ns__print_sDescResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__print_sDescResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__print_sDescResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__print_sDescResponse);
		if (size)
			*size = sizeof(struct ns__print_sDescResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__print_sDescResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__print_sDescResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__print_sDescResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__print_sDescResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__print_sDescResponse %p -> %p\n", q, p));
	*(struct ns__print_sDescResponse*)p = *(struct ns__print_sDescResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__start_ssession(struct soap *soap, struct ns__start_ssession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_sourceDesc_t(soap, &a->sDec);
	soap_default_senderDesc_t(soap, &a->senderDesc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__start_ssession(struct soap *soap, const struct ns__start_ssession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_sourceDesc_t(soap, &a->sDec);
	soap_serialize_senderDesc_t(soap, &a->senderDesc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__start_ssession(struct soap *soap, const char *tag, int id, const struct ns__start_ssession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__start_ssession), type))
		return soap->error;
	if (soap_out_sourceDesc_t(soap, "sDec", -1, &a->sDec, ""))
		return soap->error;
	if (soap_out_senderDesc_t(soap, "senderDesc", -1, &a->senderDesc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__start_ssession * SOAP_FMAC4 soap_in_ns__start_ssession(struct soap *soap, const char *tag, struct ns__start_ssession *a, const char *type)
{
	size_t soap_flag_sDec = 1;
	size_t soap_flag_senderDesc = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__start_ssession *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__start_ssession, sizeof(struct ns__start_ssession), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__start_ssession(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sDec && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_sourceDesc_t(soap, "sDec", &a->sDec, "sourceDesc-t"))
				{	soap_flag_sDec--;
					continue;
				}
			if (soap_flag_senderDesc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_senderDesc_t(soap, "senderDesc", &a->senderDesc, "senderDesc-t"))
				{	soap_flag_senderDesc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__start_ssession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__start_ssession, 0, sizeof(struct ns__start_ssession), 0, soap_copy_ns__start_ssession);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sDec > 0 || soap_flag_senderDesc > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__start_ssession(struct soap *soap, const struct ns__start_ssession *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__start_ssession);
	if (soap_out_ns__start_ssession(soap, tag?tag:"ns:start-ssession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__start_ssession * SOAP_FMAC4 soap_get_ns__start_ssession(struct soap *soap, struct ns__start_ssession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__start_ssession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__start_ssession * SOAP_FMAC2 soap_instantiate_ns__start_ssession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__start_ssession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__start_ssession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_ssession);
		if (size)
			*size = sizeof(struct ns__start_ssession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_ssession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__start_ssession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__start_ssession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__start_ssession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__start_ssession %p -> %p\n", q, p));
	*(struct ns__start_ssession*)p = *(struct ns__start_ssession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__start_ssessionResponse(struct soap *soap, struct ns__start_ssessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_StartSSessionResponse(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__start_ssessionResponse(struct soap *soap, const struct ns__start_ssessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_StartSSessionResponse(soap, &a->response);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__start_ssessionResponse(struct soap *soap, const char *tag, int id, const struct ns__start_ssessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__start_ssessionResponse), type))
		return soap->error;
	if (soap_out_StartSSessionResponse(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__start_ssessionResponse * SOAP_FMAC4 soap_in_ns__start_ssessionResponse(struct soap *soap, const char *tag, struct ns__start_ssessionResponse *a, const char *type)
{
	size_t soap_flag_response = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__start_ssessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__start_ssessionResponse, sizeof(struct ns__start_ssessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__start_ssessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_StartSSessionResponse(soap, "response", &a->response, "StartSSessionResponse"))
				{	soap_flag_response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__start_ssessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__start_ssessionResponse, 0, sizeof(struct ns__start_ssessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__start_ssessionResponse(struct soap *soap, const struct ns__start_ssessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__start_ssessionResponse);
	if (soap_out_ns__start_ssessionResponse(soap, tag?tag:"ns:start-ssessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__start_ssessionResponse * SOAP_FMAC4 soap_get_ns__start_ssessionResponse(struct soap *soap, struct ns__start_ssessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__start_ssessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__start_ssessionResponse * SOAP_FMAC2 soap_instantiate_ns__start_ssessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__start_ssessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__start_ssessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_ssessionResponse);
		if (size)
			*size = sizeof(struct ns__start_ssessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_ssessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__start_ssessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__start_ssessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__start_ssessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__start_ssessionResponse %p -> %p\n", q, p));
	*(struct ns__start_ssessionResponse*)p = *(struct ns__start_ssessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_StartSSessionResponse(struct soap *soap, struct StartSSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_StartSSessionResponse(struct soap *soap, const struct StartSSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_StartSSessionResponse(struct soap *soap, const char *tag, int id, const struct StartSSessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_StartSSessionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct StartSSessionResponse * SOAP_FMAC4 soap_in_StartSSessionResponse(struct soap *soap, const char *tag, struct StartSSessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct StartSSessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_StartSSessionResponse, sizeof(struct StartSSessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_StartSSessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct StartSSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_StartSSessionResponse, 0, sizeof(struct StartSSessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_StartSSessionResponse(struct soap *soap, const struct StartSSessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_StartSSessionResponse);
	if (soap_out_StartSSessionResponse(soap, tag?tag:"StartSSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct StartSSessionResponse * SOAP_FMAC4 soap_get_StartSSessionResponse(struct soap *soap, struct StartSSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_StartSSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct StartSSessionResponse * SOAP_FMAC2 soap_instantiate_StartSSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_StartSSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_StartSSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct StartSSessionResponse);
		if (size)
			*size = sizeof(struct StartSSessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct StartSSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct StartSSessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct StartSSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_StartSSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct StartSSessionResponse %p -> %p\n", q, p));
	*(struct StartSSessionResponse*)p = *(struct StartSSessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__start_rsession(struct soap *soap, struct ns__start_rsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_sourceDesc_t(soap, &a->sDec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__start_rsession(struct soap *soap, const struct ns__start_rsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_sourceDesc_t(soap, &a->sDec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__start_rsession(struct soap *soap, const char *tag, int id, const struct ns__start_rsession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__start_rsession), type))
		return soap->error;
	if (soap_out_sourceDesc_t(soap, "sDec", -1, &a->sDec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__start_rsession * SOAP_FMAC4 soap_in_ns__start_rsession(struct soap *soap, const char *tag, struct ns__start_rsession *a, const char *type)
{
	size_t soap_flag_sDec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__start_rsession *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__start_rsession, sizeof(struct ns__start_rsession), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__start_rsession(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sDec && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_sourceDesc_t(soap, "sDec", &a->sDec, "sourceDesc-t"))
				{	soap_flag_sDec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__start_rsession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__start_rsession, 0, sizeof(struct ns__start_rsession), 0, soap_copy_ns__start_rsession);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sDec > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__start_rsession(struct soap *soap, const struct ns__start_rsession *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__start_rsession);
	if (soap_out_ns__start_rsession(soap, tag?tag:"ns:start-rsession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__start_rsession * SOAP_FMAC4 soap_get_ns__start_rsession(struct soap *soap, struct ns__start_rsession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__start_rsession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__start_rsession * SOAP_FMAC2 soap_instantiate_ns__start_rsession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__start_rsession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__start_rsession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_rsession);
		if (size)
			*size = sizeof(struct ns__start_rsession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_rsession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__start_rsession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__start_rsession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__start_rsession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__start_rsession %p -> %p\n", q, p));
	*(struct ns__start_rsession*)p = *(struct ns__start_rsession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__start_rsessionResponse(struct soap *soap, struct ns__start_rsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_StartRSessionResponse(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__start_rsessionResponse(struct soap *soap, const struct ns__start_rsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_StartRSessionResponse(soap, &a->response);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__start_rsessionResponse(struct soap *soap, const char *tag, int id, const struct ns__start_rsessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__start_rsessionResponse), type))
		return soap->error;
	if (soap_out_StartRSessionResponse(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__start_rsessionResponse * SOAP_FMAC4 soap_in_ns__start_rsessionResponse(struct soap *soap, const char *tag, struct ns__start_rsessionResponse *a, const char *type)
{
	size_t soap_flag_response = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__start_rsessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__start_rsessionResponse, sizeof(struct ns__start_rsessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__start_rsessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_StartRSessionResponse(soap, "response", &a->response, "StartRSessionResponse"))
				{	soap_flag_response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__start_rsessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__start_rsessionResponse, 0, sizeof(struct ns__start_rsessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__start_rsessionResponse(struct soap *soap, const struct ns__start_rsessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__start_rsessionResponse);
	if (soap_out_ns__start_rsessionResponse(soap, tag?tag:"ns:start-rsessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__start_rsessionResponse * SOAP_FMAC4 soap_get_ns__start_rsessionResponse(struct soap *soap, struct ns__start_rsessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__start_rsessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__start_rsessionResponse * SOAP_FMAC2 soap_instantiate_ns__start_rsessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__start_rsessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__start_rsessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_rsessionResponse);
		if (size)
			*size = sizeof(struct ns__start_rsessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_rsessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__start_rsessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__start_rsessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__start_rsessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__start_rsessionResponse %p -> %p\n", q, p));
	*(struct ns__start_rsessionResponse*)p = *(struct ns__start_rsessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_StartRSessionResponse(struct soap *soap, struct StartRSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_StartRSessionResponse(struct soap *soap, const struct StartRSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_StartRSessionResponse(struct soap *soap, const char *tag, int id, const struct StartRSessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_StartRSessionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct StartRSessionResponse * SOAP_FMAC4 soap_in_StartRSessionResponse(struct soap *soap, const char *tag, struct StartRSessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct StartRSessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_StartRSessionResponse, sizeof(struct StartRSessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_StartRSessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct StartRSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_StartRSessionResponse, 0, sizeof(struct StartRSessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_StartRSessionResponse(struct soap *soap, const struct StartRSessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_StartRSessionResponse);
	if (soap_out_StartRSessionResponse(soap, tag?tag:"StartRSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct StartRSessionResponse * SOAP_FMAC4 soap_get_StartRSessionResponse(struct soap *soap, struct StartRSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_StartRSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct StartRSessionResponse * SOAP_FMAC2 soap_instantiate_StartRSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_StartRSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_StartRSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct StartRSessionResponse);
		if (size)
			*size = sizeof(struct StartRSessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct StartRSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct StartRSessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct StartRSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_StartRSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct StartRSessionResponse %p -> %p\n", q, p));
	*(struct StartRSessionResponse*)p = *(struct StartRSessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__release_UDP_time_port(struct soap *soap, struct ns__release_UDP_time_port *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__release_UDP_time_port(struct soap *soap, const struct ns__release_UDP_time_port *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__release_UDP_time_port(struct soap *soap, const char *tag, int id, const struct ns__release_UDP_time_port *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__release_UDP_time_port), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__release_UDP_time_port * SOAP_FMAC4 soap_in_ns__release_UDP_time_port(struct soap *soap, const char *tag, struct ns__release_UDP_time_port *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__release_UDP_time_port *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__release_UDP_time_port, sizeof(struct ns__release_UDP_time_port), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__release_UDP_time_port(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__release_UDP_time_port *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__release_UDP_time_port, 0, sizeof(struct ns__release_UDP_time_port), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__release_UDP_time_port(struct soap *soap, const struct ns__release_UDP_time_port *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__release_UDP_time_port);
	if (soap_out_ns__release_UDP_time_port(soap, tag?tag:"ns:release-UDP-time-port", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__release_UDP_time_port * SOAP_FMAC4 soap_get_ns__release_UDP_time_port(struct soap *soap, struct ns__release_UDP_time_port *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__release_UDP_time_port(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__release_UDP_time_port * SOAP_FMAC2 soap_instantiate_ns__release_UDP_time_port(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__release_UDP_time_port(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__release_UDP_time_port, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_UDP_time_port);
		if (size)
			*size = sizeof(struct ns__release_UDP_time_port);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_UDP_time_port[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__release_UDP_time_port);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__release_UDP_time_port*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__release_UDP_time_port(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__release_UDP_time_port %p -> %p\n", q, p));
	*(struct ns__release_UDP_time_port*)p = *(struct ns__release_UDP_time_port*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__release_UDP_time_portResponse(struct soap *soap, struct ns__release_UDP_time_portResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ReleaseUDPTimePortResponse(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__release_UDP_time_portResponse(struct soap *soap, const struct ns__release_UDP_time_portResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ReleaseUDPTimePortResponse(soap, &a->response);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__release_UDP_time_portResponse(struct soap *soap, const char *tag, int id, const struct ns__release_UDP_time_portResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__release_UDP_time_portResponse), type))
		return soap->error;
	if (soap_out_ReleaseUDPTimePortResponse(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__release_UDP_time_portResponse * SOAP_FMAC4 soap_in_ns__release_UDP_time_portResponse(struct soap *soap, const char *tag, struct ns__release_UDP_time_portResponse *a, const char *type)
{
	size_t soap_flag_response = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__release_UDP_time_portResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__release_UDP_time_portResponse, sizeof(struct ns__release_UDP_time_portResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__release_UDP_time_portResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ReleaseUDPTimePortResponse(soap, "response", &a->response, "ReleaseUDPTimePortResponse"))
				{	soap_flag_response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__release_UDP_time_portResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__release_UDP_time_portResponse, 0, sizeof(struct ns__release_UDP_time_portResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__release_UDP_time_portResponse(struct soap *soap, const struct ns__release_UDP_time_portResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__release_UDP_time_portResponse);
	if (soap_out_ns__release_UDP_time_portResponse(soap, tag?tag:"ns:release-UDP-time-portResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__release_UDP_time_portResponse * SOAP_FMAC4 soap_get_ns__release_UDP_time_portResponse(struct soap *soap, struct ns__release_UDP_time_portResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__release_UDP_time_portResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__release_UDP_time_portResponse * SOAP_FMAC2 soap_instantiate_ns__release_UDP_time_portResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__release_UDP_time_portResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__release_UDP_time_portResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_UDP_time_portResponse);
		if (size)
			*size = sizeof(struct ns__release_UDP_time_portResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_UDP_time_portResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__release_UDP_time_portResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__release_UDP_time_portResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__release_UDP_time_portResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__release_UDP_time_portResponse %p -> %p\n", q, p));
	*(struct ns__release_UDP_time_portResponse*)p = *(struct ns__release_UDP_time_portResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ReleaseUDPTimePortResponse(struct soap *soap, struct ReleaseUDPTimePortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ReleaseUDPTimePortResponse(struct soap *soap, const struct ReleaseUDPTimePortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ReleaseUDPTimePortResponse(struct soap *soap, const char *tag, int id, const struct ReleaseUDPTimePortResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ReleaseUDPTimePortResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ReleaseUDPTimePortResponse * SOAP_FMAC4 soap_in_ReleaseUDPTimePortResponse(struct soap *soap, const char *tag, struct ReleaseUDPTimePortResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ReleaseUDPTimePortResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ReleaseUDPTimePortResponse, sizeof(struct ReleaseUDPTimePortResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ReleaseUDPTimePortResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ReleaseUDPTimePortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ReleaseUDPTimePortResponse, 0, sizeof(struct ReleaseUDPTimePortResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ReleaseUDPTimePortResponse(struct soap *soap, const struct ReleaseUDPTimePortResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ReleaseUDPTimePortResponse);
	if (soap_out_ReleaseUDPTimePortResponse(soap, tag?tag:"ReleaseUDPTimePortResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ReleaseUDPTimePortResponse * SOAP_FMAC4 soap_get_ReleaseUDPTimePortResponse(struct soap *soap, struct ReleaseUDPTimePortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ReleaseUDPTimePortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ReleaseUDPTimePortResponse * SOAP_FMAC2 soap_instantiate_ReleaseUDPTimePortResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ReleaseUDPTimePortResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ReleaseUDPTimePortResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ReleaseUDPTimePortResponse);
		if (size)
			*size = sizeof(struct ReleaseUDPTimePortResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ReleaseUDPTimePortResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ReleaseUDPTimePortResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ReleaseUDPTimePortResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ReleaseUDPTimePortResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ReleaseUDPTimePortResponse %p -> %p\n", q, p));
	*(struct ReleaseUDPTimePortResponse*)p = *(struct ReleaseUDPTimePortResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__start_UDP_time_port(struct soap *soap, struct ns__start_UDP_time_port *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedShort(soap, &a->pPort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__start_UDP_time_port(struct soap *soap, const struct ns__start_UDP_time_port *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__start_UDP_time_port(struct soap *soap, const char *tag, int id, const struct ns__start_UDP_time_port *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__start_UDP_time_port), type))
		return soap->error;
	if (soap_out_unsignedShort(soap, "pPort", -1, &a->pPort, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__start_UDP_time_port * SOAP_FMAC4 soap_in_ns__start_UDP_time_port(struct soap *soap, const char *tag, struct ns__start_UDP_time_port *a, const char *type)
{
	size_t soap_flag_pPort = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__start_UDP_time_port *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__start_UDP_time_port, sizeof(struct ns__start_UDP_time_port), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__start_UDP_time_port(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedShort(soap, "pPort", &a->pPort, "xsd:unsignedShort"))
				{	soap_flag_pPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__start_UDP_time_port *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__start_UDP_time_port, 0, sizeof(struct ns__start_UDP_time_port), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pPort > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__start_UDP_time_port(struct soap *soap, const struct ns__start_UDP_time_port *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__start_UDP_time_port);
	if (soap_out_ns__start_UDP_time_port(soap, tag?tag:"ns:start-UDP-time-port", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__start_UDP_time_port * SOAP_FMAC4 soap_get_ns__start_UDP_time_port(struct soap *soap, struct ns__start_UDP_time_port *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__start_UDP_time_port(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__start_UDP_time_port * SOAP_FMAC2 soap_instantiate_ns__start_UDP_time_port(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__start_UDP_time_port(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__start_UDP_time_port, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_UDP_time_port);
		if (size)
			*size = sizeof(struct ns__start_UDP_time_port);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_UDP_time_port[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__start_UDP_time_port);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__start_UDP_time_port*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__start_UDP_time_port(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__start_UDP_time_port %p -> %p\n", q, p));
	*(struct ns__start_UDP_time_port*)p = *(struct ns__start_UDP_time_port*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__start_UDP_time_portResponse(struct soap *soap, struct ns__start_UDP_time_portResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedShort(soap, &a->OPort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__start_UDP_time_portResponse(struct soap *soap, const struct ns__start_UDP_time_portResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__start_UDP_time_portResponse(struct soap *soap, const char *tag, int id, const struct ns__start_UDP_time_portResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__start_UDP_time_portResponse), type))
		return soap->error;
	if (soap_out_unsignedShort(soap, "OPort", -1, &a->OPort, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__start_UDP_time_portResponse * SOAP_FMAC4 soap_in_ns__start_UDP_time_portResponse(struct soap *soap, const char *tag, struct ns__start_UDP_time_portResponse *a, const char *type)
{
	size_t soap_flag_OPort = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__start_UDP_time_portResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__start_UDP_time_portResponse, sizeof(struct ns__start_UDP_time_portResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__start_UDP_time_portResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedShort(soap, "OPort", &a->OPort, "xsd:unsignedShort"))
				{	soap_flag_OPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__start_UDP_time_portResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__start_UDP_time_portResponse, 0, sizeof(struct ns__start_UDP_time_portResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OPort > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__start_UDP_time_portResponse(struct soap *soap, const struct ns__start_UDP_time_portResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__start_UDP_time_portResponse);
	if (soap_out_ns__start_UDP_time_portResponse(soap, tag?tag:"ns:start-UDP-time-portResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__start_UDP_time_portResponse * SOAP_FMAC4 soap_get_ns__start_UDP_time_portResponse(struct soap *soap, struct ns__start_UDP_time_portResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__start_UDP_time_portResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__start_UDP_time_portResponse * SOAP_FMAC2 soap_instantiate_ns__start_UDP_time_portResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__start_UDP_time_portResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__start_UDP_time_portResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_UDP_time_portResponse);
		if (size)
			*size = sizeof(struct ns__start_UDP_time_portResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__start_UDP_time_portResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__start_UDP_time_portResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__start_UDP_time_portResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__start_UDP_time_portResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__start_UDP_time_portResponse %p -> %p\n", q, p));
	*(struct ns__start_UDP_time_portResponse*)p = *(struct ns__start_UDP_time_portResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_time_by_gsoap(struct soap *soap, struct ns__get_time_by_gsoap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_time_by_gsoap(struct soap *soap, const struct ns__get_time_by_gsoap *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_time_by_gsoap(struct soap *soap, const char *tag, int id, const struct ns__get_time_by_gsoap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_time_by_gsoap), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_time_by_gsoap * SOAP_FMAC4 soap_in_ns__get_time_by_gsoap(struct soap *soap, const char *tag, struct ns__get_time_by_gsoap *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__get_time_by_gsoap *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_time_by_gsoap, sizeof(struct ns__get_time_by_gsoap), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_time_by_gsoap(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_time_by_gsoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_time_by_gsoap, 0, sizeof(struct ns__get_time_by_gsoap), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_time_by_gsoap(struct soap *soap, const struct ns__get_time_by_gsoap *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__get_time_by_gsoap);
	if (soap_out_ns__get_time_by_gsoap(soap, tag?tag:"ns:get-time-by-gsoap", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_time_by_gsoap * SOAP_FMAC4 soap_get_ns__get_time_by_gsoap(struct soap *soap, struct ns__get_time_by_gsoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_time_by_gsoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__get_time_by_gsoap * SOAP_FMAC2 soap_instantiate_ns__get_time_by_gsoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_time_by_gsoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__get_time_by_gsoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_time_by_gsoap);
		if (size)
			*size = sizeof(struct ns__get_time_by_gsoap);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_time_by_gsoap[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__get_time_by_gsoap);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__get_time_by_gsoap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__get_time_by_gsoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__get_time_by_gsoap %p -> %p\n", q, p));
	*(struct ns__get_time_by_gsoap*)p = *(struct ns__get_time_by_gsoap*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_time_by_gsoapResponse(struct soap *soap, struct ns__get_time_by_gsoapResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tv_type(soap, &a->ptv);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_time_by_gsoapResponse(struct soap *soap, const struct ns__get_time_by_gsoapResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tv_type(soap, &a->ptv);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_time_by_gsoapResponse(struct soap *soap, const char *tag, int id, const struct ns__get_time_by_gsoapResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_time_by_gsoapResponse), type))
		return soap->error;
	if (soap_out_tv_type(soap, "ptv", -1, &a->ptv, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_time_by_gsoapResponse * SOAP_FMAC4 soap_in_ns__get_time_by_gsoapResponse(struct soap *soap, const char *tag, struct ns__get_time_by_gsoapResponse *a, const char *type)
{
	size_t soap_flag_ptv = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__get_time_by_gsoapResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_time_by_gsoapResponse, sizeof(struct ns__get_time_by_gsoapResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_time_by_gsoapResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ptv && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "ptv", &a->ptv, "tv-type"))
				{	soap_flag_ptv--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_time_by_gsoapResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_time_by_gsoapResponse, 0, sizeof(struct ns__get_time_by_gsoapResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ptv > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_time_by_gsoapResponse(struct soap *soap, const struct ns__get_time_by_gsoapResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__get_time_by_gsoapResponse);
	if (soap_out_ns__get_time_by_gsoapResponse(soap, tag?tag:"ns:get-time-by-gsoapResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_time_by_gsoapResponse * SOAP_FMAC4 soap_get_ns__get_time_by_gsoapResponse(struct soap *soap, struct ns__get_time_by_gsoapResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_time_by_gsoapResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__get_time_by_gsoapResponse * SOAP_FMAC2 soap_instantiate_ns__get_time_by_gsoapResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_time_by_gsoapResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__get_time_by_gsoapResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_time_by_gsoapResponse);
		if (size)
			*size = sizeof(struct ns__get_time_by_gsoapResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_time_by_gsoapResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__get_time_by_gsoapResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__get_time_by_gsoapResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__get_time_by_gsoapResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__get_time_by_gsoapResponse %p -> %p\n", q, p));
	*(struct ns__get_time_by_gsoapResponse*)p = *(struct ns__get_time_by_gsoapResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__finish_session(struct soap *soap, struct ns__finish_session *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->pLastSeqNo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__finish_session(struct soap *soap, const struct ns__finish_session *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__finish_session(struct soap *soap, const char *tag, int id, const struct ns__finish_session *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__finish_session), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "pLastSeqNo", -1, &a->pLastSeqNo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__finish_session * SOAP_FMAC4 soap_in_ns__finish_session(struct soap *soap, const char *tag, struct ns__finish_session *a, const char *type)
{
	size_t soap_flag_pLastSeqNo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__finish_session *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__finish_session, sizeof(struct ns__finish_session), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__finish_session(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLastSeqNo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "pLastSeqNo", &a->pLastSeqNo, "xsd:unsignedInt"))
				{	soap_flag_pLastSeqNo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__finish_session *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__finish_session, 0, sizeof(struct ns__finish_session), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pLastSeqNo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__finish_session(struct soap *soap, const struct ns__finish_session *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__finish_session);
	if (soap_out_ns__finish_session(soap, tag?tag:"ns:finish-session", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__finish_session * SOAP_FMAC4 soap_get_ns__finish_session(struct soap *soap, struct ns__finish_session *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__finish_session(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__finish_session * SOAP_FMAC2 soap_instantiate_ns__finish_session(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__finish_session(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__finish_session, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__finish_session);
		if (size)
			*size = sizeof(struct ns__finish_session);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__finish_session[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__finish_session);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__finish_session*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__finish_session(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__finish_session %p -> %p\n", q, p));
	*(struct ns__finish_session*)p = *(struct ns__finish_session*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__finish_sessionResponse(struct soap *soap, struct ns__finish_sessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_FinishSessionResponse(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__finish_sessionResponse(struct soap *soap, const struct ns__finish_sessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_FinishSessionResponse(soap, &a->response);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__finish_sessionResponse(struct soap *soap, const char *tag, int id, const struct ns__finish_sessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__finish_sessionResponse), type))
		return soap->error;
	if (soap_out_FinishSessionResponse(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__finish_sessionResponse * SOAP_FMAC4 soap_in_ns__finish_sessionResponse(struct soap *soap, const char *tag, struct ns__finish_sessionResponse *a, const char *type)
{
	size_t soap_flag_response = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__finish_sessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__finish_sessionResponse, sizeof(struct ns__finish_sessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__finish_sessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_FinishSessionResponse(soap, "response", &a->response, "FinishSessionResponse"))
				{	soap_flag_response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__finish_sessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__finish_sessionResponse, 0, sizeof(struct ns__finish_sessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__finish_sessionResponse(struct soap *soap, const struct ns__finish_sessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__finish_sessionResponse);
	if (soap_out_ns__finish_sessionResponse(soap, tag?tag:"ns:finish-sessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__finish_sessionResponse * SOAP_FMAC4 soap_get_ns__finish_sessionResponse(struct soap *soap, struct ns__finish_sessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__finish_sessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__finish_sessionResponse * SOAP_FMAC2 soap_instantiate_ns__finish_sessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__finish_sessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__finish_sessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__finish_sessionResponse);
		if (size)
			*size = sizeof(struct ns__finish_sessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__finish_sessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__finish_sessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__finish_sessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__finish_sessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__finish_sessionResponse %p -> %p\n", q, p));
	*(struct ns__finish_sessionResponse*)p = *(struct ns__finish_sessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_FinishSessionResponse(struct soap *soap, struct FinishSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_FinishSessionResponse(struct soap *soap, const struct FinishSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FinishSessionResponse(struct soap *soap, const char *tag, int id, const struct FinishSessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_FinishSessionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct FinishSessionResponse * SOAP_FMAC4 soap_in_FinishSessionResponse(struct soap *soap, const char *tag, struct FinishSessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct FinishSessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FinishSessionResponse, sizeof(struct FinishSessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_FinishSessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct FinishSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FinishSessionResponse, 0, sizeof(struct FinishSessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_FinishSessionResponse(struct soap *soap, const struct FinishSessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_FinishSessionResponse);
	if (soap_out_FinishSessionResponse(soap, tag?tag:"FinishSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FinishSessionResponse * SOAP_FMAC4 soap_get_FinishSessionResponse(struct soap *soap, struct FinishSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_FinishSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct FinishSessionResponse * SOAP_FMAC2 soap_instantiate_FinishSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_FinishSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_FinishSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct FinishSessionResponse);
		if (size)
			*size = sizeof(struct FinishSessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct FinishSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct FinishSessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct FinishSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_FinishSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct FinishSessionResponse %p -> %p\n", q, p));
	*(struct FinishSessionResponse*)p = *(struct FinishSessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_samples(struct soap *soap, struct ns__get_samples *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_samples(struct soap *soap, const struct ns__get_samples *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_samples(struct soap *soap, const char *tag, int id, const struct ns__get_samples *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_samples), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_samples * SOAP_FMAC4 soap_in_ns__get_samples(struct soap *soap, const char *tag, struct ns__get_samples *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__get_samples *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_samples, sizeof(struct ns__get_samples), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_samples(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_samples *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_samples, 0, sizeof(struct ns__get_samples), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_samples(struct soap *soap, const struct ns__get_samples *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__get_samples);
	if (soap_out_ns__get_samples(soap, tag?tag:"ns:get-samples", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_samples * SOAP_FMAC4 soap_get_ns__get_samples(struct soap *soap, struct ns__get_samples *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_samples(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__get_samples * SOAP_FMAC2 soap_instantiate_ns__get_samples(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_samples(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__get_samples, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samples);
		if (size)
			*size = sizeof(struct ns__get_samples);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samples[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__get_samples);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__get_samples*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__get_samples(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__get_samples %p -> %p\n", q, p));
	*(struct ns__get_samples*)p = *(struct ns__get_samples*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_samplesResponse(struct soap *soap, struct ns__get_samplesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfsample_t(soap, &a->sample_list_t);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_samplesResponse(struct soap *soap, const struct ns__get_samplesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfsample_t(soap, &a->sample_list_t);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_samplesResponse(struct soap *soap, const char *tag, int id, const struct ns__get_samplesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_samplesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsample_t(soap, "sample-list-t", -1, &a->sample_list_t, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_samplesResponse * SOAP_FMAC4 soap_in_ns__get_samplesResponse(struct soap *soap, const char *tag, struct ns__get_samplesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__get_samplesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_samplesResponse, sizeof(struct ns__get_samplesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__get_samplesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfsample_t(soap, "sample-list-t", &a->sample_list_t, "sample-t"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_samplesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_samplesResponse, 0, sizeof(struct ns__get_samplesResponse), 0, soap_copy_ns__get_samplesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->sample_list_t.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_samplesResponse(struct soap *soap, const struct ns__get_samplesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__get_samplesResponse);
	if (soap_out_ns__get_samplesResponse(soap, tag?tag:"ns:get-samplesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_samplesResponse * SOAP_FMAC4 soap_get_ns__get_samplesResponse(struct soap *soap, struct ns__get_samplesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_samplesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__get_samplesResponse * SOAP_FMAC2 soap_instantiate_ns__get_samplesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_samplesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__get_samplesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samplesResponse);
		if (size)
			*size = sizeof(struct ns__get_samplesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samplesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__get_samplesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__get_samplesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__get_samplesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__get_samplesResponse %p -> %p\n", q, p));
	*(struct ns__get_samplesResponse*)p = *(struct ns__get_samplesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBasicSourceStats(struct soap *soap, struct ns__getBasicSourceStats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBasicSourceStats(struct soap *soap, const struct ns__getBasicSourceStats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBasicSourceStats(struct soap *soap, const char *tag, int id, const struct ns__getBasicSourceStats *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getBasicSourceStats), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__getBasicSourceStats * SOAP_FMAC4 soap_in_ns__getBasicSourceStats(struct soap *soap, const char *tag, struct ns__getBasicSourceStats *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__getBasicSourceStats *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getBasicSourceStats, sizeof(struct ns__getBasicSourceStats), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBasicSourceStats(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBasicSourceStats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__getBasicSourceStats, 0, sizeof(struct ns__getBasicSourceStats), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBasicSourceStats(struct soap *soap, const struct ns__getBasicSourceStats *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getBasicSourceStats);
	if (soap_out_ns__getBasicSourceStats(soap, tag?tag:"ns:getBasicSourceStats", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__getBasicSourceStats * SOAP_FMAC4 soap_get_ns__getBasicSourceStats(struct soap *soap, struct ns__getBasicSourceStats *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBasicSourceStats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__getBasicSourceStats * SOAP_FMAC2 soap_instantiate_ns__getBasicSourceStats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBasicSourceStats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getBasicSourceStats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__getBasicSourceStats);
		if (size)
			*size = sizeof(struct ns__getBasicSourceStats);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__getBasicSourceStats[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__getBasicSourceStats);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBasicSourceStats*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBasicSourceStats(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBasicSourceStats %p -> %p\n", q, p));
	*(struct ns__getBasicSourceStats*)p = *(struct ns__getBasicSourceStats*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__getBasicSourceStatsResponse(struct soap *soap, struct ns__getBasicSourceStatsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_BasicSourceStats_t(soap, &a->GetBasicSourceStatics);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__getBasicSourceStatsResponse(struct soap *soap, const struct ns__getBasicSourceStatsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_BasicSourceStats_t(soap, &a->GetBasicSourceStatics);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__getBasicSourceStatsResponse(struct soap *soap, const char *tag, int id, const struct ns__getBasicSourceStatsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__getBasicSourceStatsResponse), type))
		return soap->error;
	if (soap_out_BasicSourceStats_t(soap, "GetBasicSourceStatics", -1, &a->GetBasicSourceStatics, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__getBasicSourceStatsResponse * SOAP_FMAC4 soap_in_ns__getBasicSourceStatsResponse(struct soap *soap, const char *tag, struct ns__getBasicSourceStatsResponse *a, const char *type)
{
	size_t soap_flag_GetBasicSourceStatics = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__getBasicSourceStatsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__getBasicSourceStatsResponse, sizeof(struct ns__getBasicSourceStatsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__getBasicSourceStatsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetBasicSourceStatics && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_BasicSourceStats_t(soap, "GetBasicSourceStatics", &a->GetBasicSourceStatics, "BasicSourceStats-t"))
				{	soap_flag_GetBasicSourceStatics--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__getBasicSourceStatsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__getBasicSourceStatsResponse, 0, sizeof(struct ns__getBasicSourceStatsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetBasicSourceStatics > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__getBasicSourceStatsResponse(struct soap *soap, const struct ns__getBasicSourceStatsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__getBasicSourceStatsResponse);
	if (soap_out_ns__getBasicSourceStatsResponse(soap, tag?tag:"ns:getBasicSourceStatsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__getBasicSourceStatsResponse * SOAP_FMAC4 soap_get_ns__getBasicSourceStatsResponse(struct soap *soap, struct ns__getBasicSourceStatsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__getBasicSourceStatsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__getBasicSourceStatsResponse * SOAP_FMAC2 soap_instantiate_ns__getBasicSourceStatsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__getBasicSourceStatsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__getBasicSourceStatsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__getBasicSourceStatsResponse);
		if (size)
			*size = sizeof(struct ns__getBasicSourceStatsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__getBasicSourceStatsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__getBasicSourceStatsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__getBasicSourceStatsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__getBasicSourceStatsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__getBasicSourceStatsResponse %p -> %p\n", q, p));
	*(struct ns__getBasicSourceStatsResponse*)p = *(struct ns__getBasicSourceStatsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_samples_whole(struct soap *soap, struct ns__get_samples_whole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_samples_whole(struct soap *soap, const struct ns__get_samples_whole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_samples_whole(struct soap *soap, const char *tag, int id, const struct ns__get_samples_whole *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_samples_whole), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_samples_whole * SOAP_FMAC4 soap_in_ns__get_samples_whole(struct soap *soap, const char *tag, struct ns__get_samples_whole *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__get_samples_whole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_samples_whole, sizeof(struct ns__get_samples_whole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__get_samples_whole(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_samples_whole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_samples_whole, 0, sizeof(struct ns__get_samples_whole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_samples_whole(struct soap *soap, const struct ns__get_samples_whole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__get_samples_whole);
	if (soap_out_ns__get_samples_whole(soap, tag?tag:"ns:get-samples-whole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_samples_whole * SOAP_FMAC4 soap_get_ns__get_samples_whole(struct soap *soap, struct ns__get_samples_whole *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_samples_whole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__get_samples_whole * SOAP_FMAC2 soap_instantiate_ns__get_samples_whole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_samples_whole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__get_samples_whole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samples_whole);
		if (size)
			*size = sizeof(struct ns__get_samples_whole);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samples_whole[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__get_samples_whole);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__get_samples_whole*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__get_samples_whole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__get_samples_whole %p -> %p\n", q, p));
	*(struct ns__get_samples_whole*)p = *(struct ns__get_samples_whole*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__get_samples_wholeResponse(struct soap *soap, struct ns__get_samples_wholeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfwhole_sample_t(soap, &a->GetSampleList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__get_samples_wholeResponse(struct soap *soap, const struct ns__get_samples_wholeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfwhole_sample_t(soap, &a->GetSampleList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__get_samples_wholeResponse(struct soap *soap, const char *tag, int id, const struct ns__get_samples_wholeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__get_samples_wholeResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwhole_sample_t(soap, "GetSampleList", -1, &a->GetSampleList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__get_samples_wholeResponse * SOAP_FMAC4 soap_in_ns__get_samples_wholeResponse(struct soap *soap, const char *tag, struct ns__get_samples_wholeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__get_samples_wholeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns__get_samples_wholeResponse, sizeof(struct ns__get_samples_wholeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns__get_samples_wholeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwhole_sample_t(soap, "GetSampleList", &a->GetSampleList, "whole-sample-t"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__get_samples_wholeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__get_samples_wholeResponse, 0, sizeof(struct ns__get_samples_wholeResponse), 0, soap_copy_ns__get_samples_wholeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->GetSampleList.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__get_samples_wholeResponse(struct soap *soap, const struct ns__get_samples_wholeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__get_samples_wholeResponse);
	if (soap_out_ns__get_samples_wholeResponse(soap, tag?tag:"ns:get-samples-wholeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__get_samples_wholeResponse * SOAP_FMAC4 soap_get_ns__get_samples_wholeResponse(struct soap *soap, struct ns__get_samples_wholeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__get_samples_wholeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__get_samples_wholeResponse * SOAP_FMAC2 soap_instantiate_ns__get_samples_wholeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__get_samples_wholeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__get_samples_wholeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samples_wholeResponse);
		if (size)
			*size = sizeof(struct ns__get_samples_wholeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__get_samples_wholeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__get_samples_wholeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__get_samples_wholeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__get_samples_wholeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__get_samples_wholeResponse %p -> %p\n", q, p));
	*(struct ns__get_samples_wholeResponse*)p = *(struct ns__get_samples_wholeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__release_rsession(struct soap *soap, struct ns__release_rsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__release_rsession(struct soap *soap, const struct ns__release_rsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__release_rsession(struct soap *soap, const char *tag, int id, const struct ns__release_rsession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__release_rsession), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__release_rsession * SOAP_FMAC4 soap_in_ns__release_rsession(struct soap *soap, const char *tag, struct ns__release_rsession *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__release_rsession *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__release_rsession, sizeof(struct ns__release_rsession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__release_rsession(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__release_rsession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__release_rsession, 0, sizeof(struct ns__release_rsession), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__release_rsession(struct soap *soap, const struct ns__release_rsession *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__release_rsession);
	if (soap_out_ns__release_rsession(soap, tag?tag:"ns:release-rsession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__release_rsession * SOAP_FMAC4 soap_get_ns__release_rsession(struct soap *soap, struct ns__release_rsession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__release_rsession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__release_rsession * SOAP_FMAC2 soap_instantiate_ns__release_rsession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__release_rsession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__release_rsession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_rsession);
		if (size)
			*size = sizeof(struct ns__release_rsession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_rsession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__release_rsession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__release_rsession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__release_rsession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__release_rsession %p -> %p\n", q, p));
	*(struct ns__release_rsession*)p = *(struct ns__release_rsession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__release_rsessionResponse(struct soap *soap, struct ns__release_rsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ReleaseRSessionResponse(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__release_rsessionResponse(struct soap *soap, const struct ns__release_rsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ReleaseRSessionResponse(soap, &a->response);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__release_rsessionResponse(struct soap *soap, const char *tag, int id, const struct ns__release_rsessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__release_rsessionResponse), type))
		return soap->error;
	if (soap_out_ReleaseRSessionResponse(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__release_rsessionResponse * SOAP_FMAC4 soap_in_ns__release_rsessionResponse(struct soap *soap, const char *tag, struct ns__release_rsessionResponse *a, const char *type)
{
	size_t soap_flag_response = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__release_rsessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__release_rsessionResponse, sizeof(struct ns__release_rsessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__release_rsessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ReleaseRSessionResponse(soap, "response", &a->response, "ReleaseRSessionResponse"))
				{	soap_flag_response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__release_rsessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__release_rsessionResponse, 0, sizeof(struct ns__release_rsessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__release_rsessionResponse(struct soap *soap, const struct ns__release_rsessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__release_rsessionResponse);
	if (soap_out_ns__release_rsessionResponse(soap, tag?tag:"ns:release-rsessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__release_rsessionResponse * SOAP_FMAC4 soap_get_ns__release_rsessionResponse(struct soap *soap, struct ns__release_rsessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__release_rsessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__release_rsessionResponse * SOAP_FMAC2 soap_instantiate_ns__release_rsessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__release_rsessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__release_rsessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_rsessionResponse);
		if (size)
			*size = sizeof(struct ns__release_rsessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_rsessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__release_rsessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__release_rsessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__release_rsessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__release_rsessionResponse %p -> %p\n", q, p));
	*(struct ns__release_rsessionResponse*)p = *(struct ns__release_rsessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ReleaseRSessionResponse(struct soap *soap, struct ReleaseRSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ReleaseRSessionResponse(struct soap *soap, const struct ReleaseRSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ReleaseRSessionResponse(struct soap *soap, const char *tag, int id, const struct ReleaseRSessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ReleaseRSessionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ReleaseRSessionResponse * SOAP_FMAC4 soap_in_ReleaseRSessionResponse(struct soap *soap, const char *tag, struct ReleaseRSessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ReleaseRSessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ReleaseRSessionResponse, sizeof(struct ReleaseRSessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ReleaseRSessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ReleaseRSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ReleaseRSessionResponse, 0, sizeof(struct ReleaseRSessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ReleaseRSessionResponse(struct soap *soap, const struct ReleaseRSessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ReleaseRSessionResponse);
	if (soap_out_ReleaseRSessionResponse(soap, tag?tag:"ReleaseRSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ReleaseRSessionResponse * SOAP_FMAC4 soap_get_ReleaseRSessionResponse(struct soap *soap, struct ReleaseRSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ReleaseRSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ReleaseRSessionResponse * SOAP_FMAC2 soap_instantiate_ReleaseRSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ReleaseRSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ReleaseRSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ReleaseRSessionResponse);
		if (size)
			*size = sizeof(struct ReleaseRSessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ReleaseRSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ReleaseRSessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ReleaseRSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ReleaseRSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ReleaseRSessionResponse %p -> %p\n", q, p));
	*(struct ReleaseRSessionResponse*)p = *(struct ReleaseRSessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__release_ssession(struct soap *soap, struct ns__release_ssession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__release_ssession(struct soap *soap, const struct ns__release_ssession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__release_ssession(struct soap *soap, const char *tag, int id, const struct ns__release_ssession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__release_ssession), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__release_ssession * SOAP_FMAC4 soap_in_ns__release_ssession(struct soap *soap, const char *tag, struct ns__release_ssession *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__release_ssession *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__release_ssession, sizeof(struct ns__release_ssession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__release_ssession(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__release_ssession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__release_ssession, 0, sizeof(struct ns__release_ssession), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__release_ssession(struct soap *soap, const struct ns__release_ssession *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__release_ssession);
	if (soap_out_ns__release_ssession(soap, tag?tag:"ns:release-ssession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__release_ssession * SOAP_FMAC4 soap_get_ns__release_ssession(struct soap *soap, struct ns__release_ssession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__release_ssession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__release_ssession * SOAP_FMAC2 soap_instantiate_ns__release_ssession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__release_ssession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__release_ssession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_ssession);
		if (size)
			*size = sizeof(struct ns__release_ssession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_ssession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__release_ssession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__release_ssession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__release_ssession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__release_ssession %p -> %p\n", q, p));
	*(struct ns__release_ssession*)p = *(struct ns__release_ssession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__release_ssessionResponse(struct soap *soap, struct ns__release_ssessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ReleaseSSessionResponse(soap, &a->response);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__release_ssessionResponse(struct soap *soap, const struct ns__release_ssessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_ReleaseSSessionResponse(soap, &a->response);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__release_ssessionResponse(struct soap *soap, const char *tag, int id, const struct ns__release_ssessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__release_ssessionResponse), type))
		return soap->error;
	if (soap_out_ReleaseSSessionResponse(soap, "response", -1, &a->response, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__release_ssessionResponse * SOAP_FMAC4 soap_in_ns__release_ssessionResponse(struct soap *soap, const char *tag, struct ns__release_ssessionResponse *a, const char *type)
{
	size_t soap_flag_response = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__release_ssessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__release_ssessionResponse, sizeof(struct ns__release_ssessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__release_ssessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ReleaseSSessionResponse(soap, "response", &a->response, "ReleaseSSessionResponse"))
				{	soap_flag_response--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__release_ssessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__release_ssessionResponse, 0, sizeof(struct ns__release_ssessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__release_ssessionResponse(struct soap *soap, const struct ns__release_ssessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__release_ssessionResponse);
	if (soap_out_ns__release_ssessionResponse(soap, tag?tag:"ns:release-ssessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__release_ssessionResponse * SOAP_FMAC4 soap_get_ns__release_ssessionResponse(struct soap *soap, struct ns__release_ssessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__release_ssessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__release_ssessionResponse * SOAP_FMAC2 soap_instantiate_ns__release_ssessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__release_ssessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__release_ssessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_ssessionResponse);
		if (size)
			*size = sizeof(struct ns__release_ssessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__release_ssessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__release_ssessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__release_ssessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__release_ssessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__release_ssessionResponse %p -> %p\n", q, p));
	*(struct ns__release_ssessionResponse*)p = *(struct ns__release_ssessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ReleaseSSessionResponse(struct soap *soap, struct ReleaseSSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ReleaseSSessionResponse(struct soap *soap, const struct ReleaseSSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ReleaseSSessionResponse(struct soap *soap, const char *tag, int id, const struct ReleaseSSessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ReleaseSSessionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ReleaseSSessionResponse * SOAP_FMAC4 soap_in_ReleaseSSessionResponse(struct soap *soap, const char *tag, struct ReleaseSSessionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ReleaseSSessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ReleaseSSessionResponse, sizeof(struct ReleaseSSessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ReleaseSSessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ReleaseSSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ReleaseSSessionResponse, 0, sizeof(struct ReleaseSSessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ReleaseSSessionResponse(struct soap *soap, const struct ReleaseSSessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ReleaseSSessionResponse);
	if (soap_out_ReleaseSSessionResponse(soap, tag?tag:"ReleaseSSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ReleaseSSessionResponse * SOAP_FMAC4 soap_get_ReleaseSSessionResponse(struct soap *soap, struct ReleaseSSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ReleaseSSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ReleaseSSessionResponse * SOAP_FMAC2 soap_instantiate_ReleaseSSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ReleaseSSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ReleaseSSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ReleaseSSessionResponse);
		if (size)
			*size = sizeof(struct ReleaseSSessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ReleaseSSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ReleaseSSessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ReleaseSSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ReleaseSSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ReleaseSSessionResponse %p -> %p\n", q, p));
	*(struct ReleaseSSessionResponse*)p = *(struct ReleaseSSessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Port(struct soap *soap, struct ns__Port *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Port(struct soap *soap, const struct ns__Port *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Port(struct soap *soap, const char *tag, int id, const struct ns__Port *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Port), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Port * SOAP_FMAC4 soap_in_ns__Port(struct soap *soap, const char *tag, struct ns__Port *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Port *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Port, sizeof(struct ns__Port), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__Port(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__Port *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Port, 0, sizeof(struct ns__Port), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Port(struct soap *soap, const struct ns__Port *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__Port);
	if (soap_out_ns__Port(soap, tag?tag:"ns:Port", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Port * SOAP_FMAC4 soap_get_ns__Port(struct soap *soap, struct ns__Port *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Port(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__Port * SOAP_FMAC2 soap_instantiate_ns__Port(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Port(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__Port, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Port);
		if (size)
			*size = sizeof(struct ns__Port);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__Port[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__Port);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__Port*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__Port(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__Port %p -> %p\n", q, p));
	*(struct ns__Port*)p = *(struct ns__Port*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__PortResponse(struct soap *soap, struct ns__PortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedShort(soap, &a->pPort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__PortResponse(struct soap *soap, const struct ns__PortResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__PortResponse(struct soap *soap, const char *tag, int id, const struct ns__PortResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__PortResponse), type))
		return soap->error;
	if (soap_out_unsignedShort(soap, "pPort", -1, &a->pPort, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__PortResponse * SOAP_FMAC4 soap_in_ns__PortResponse(struct soap *soap, const char *tag, struct ns__PortResponse *a, const char *type)
{
	size_t soap_flag_pPort = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__PortResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__PortResponse, sizeof(struct ns__PortResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__PortResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedShort(soap, "pPort", &a->pPort, "xsd:unsignedShort"))
				{	soap_flag_pPort--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__PortResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__PortResponse, 0, sizeof(struct ns__PortResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pPort > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__PortResponse(struct soap *soap, const struct ns__PortResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__PortResponse);
	if (soap_out_ns__PortResponse(soap, tag?tag:"ns:PortResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__PortResponse * SOAP_FMAC4 soap_get_ns__PortResponse(struct soap *soap, struct ns__PortResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__PortResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns__PortResponse * SOAP_FMAC2 soap_instantiate_ns__PortResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__PortResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns__PortResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns__PortResponse);
		if (size)
			*size = sizeof(struct ns__PortResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns__PortResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns__PortResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns__PortResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns__PortResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns__PortResponse %p -> %p\n", q, p));
	*(struct ns__PortResponse*)p = *(struct ns__PortResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_BasicSourceStats_t(struct soap *soap, struct BasicSourceStats_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tv_type(soap, &a->StartTime);
	soap_default_tv_type(soap, &a->Duration);
	soap_default_tv_type(soap, &a->FinishTime);
	soap_default_unsignedInt(soap, &a->SentPackets);
	soap_default_LONG64(soap, &a->SentBytes);
	soap_default_unsignedInt(soap, &a->RecvPackets);
	soap_default_LONG64(soap, &a->RecvBytes);
	soap_default_unsignedInt(soap, &a->Duplicates);
	soap_default_unsignedInt(soap, &a->Reordered);
	soap_default_unsignedInt(soap, &a->Corrupted);
	soap_default_LONG64(soap, &a->DeltaTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_BasicSourceStats_t(struct soap *soap, const struct BasicSourceStats_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tv_type(soap, &a->StartTime);
	soap_serialize_tv_type(soap, &a->Duration);
	soap_serialize_tv_type(soap, &a->FinishTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_BasicSourceStats_t(struct soap *soap, const char *tag, int id, const struct BasicSourceStats_t *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_BasicSourceStats_t), type))
		return soap->error;
	if (soap_out_tv_type(soap, "StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_tv_type(soap, "Duration", -1, &a->Duration, ""))
		return soap->error;
	if (soap_out_tv_type(soap, "FinishTime", -1, &a->FinishTime, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "SentPackets", -1, &a->SentPackets, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "SentBytes", -1, &a->SentBytes, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "RecvPackets", -1, &a->RecvPackets, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "RecvBytes", -1, &a->RecvBytes, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Duplicates", -1, &a->Duplicates, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Reordered", -1, &a->Reordered, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Corrupted", -1, &a->Corrupted, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "DeltaTime", -1, &a->DeltaTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct BasicSourceStats_t * SOAP_FMAC4 soap_in_BasicSourceStats_t(struct soap *soap, const char *tag, struct BasicSourceStats_t *a, const char *type)
{
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_Duration = 1;
	size_t soap_flag_FinishTime = 1;
	size_t soap_flag_SentPackets = 1;
	size_t soap_flag_SentBytes = 1;
	size_t soap_flag_RecvPackets = 1;
	size_t soap_flag_RecvBytes = 1;
	size_t soap_flag_Duplicates = 1;
	size_t soap_flag_Reordered = 1;
	size_t soap_flag_Corrupted = 1;
	size_t soap_flag_DeltaTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct BasicSourceStats_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_BasicSourceStats_t, sizeof(struct BasicSourceStats_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_BasicSourceStats_t(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "StartTime", &a->StartTime, "tv-type"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_Duration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "Duration", &a->Duration, "tv-type"))
				{	soap_flag_Duration--;
					continue;
				}
			if (soap_flag_FinishTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "FinishTime", &a->FinishTime, "tv-type"))
				{	soap_flag_FinishTime--;
					continue;
				}
			if (soap_flag_SentPackets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "SentPackets", &a->SentPackets, "xsd:unsignedInt"))
				{	soap_flag_SentPackets--;
					continue;
				}
			if (soap_flag_SentBytes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "SentBytes", &a->SentBytes, "xsd:long"))
				{	soap_flag_SentBytes--;
					continue;
				}
			if (soap_flag_RecvPackets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "RecvPackets", &a->RecvPackets, "xsd:unsignedInt"))
				{	soap_flag_RecvPackets--;
					continue;
				}
			if (soap_flag_RecvBytes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "RecvBytes", &a->RecvBytes, "xsd:long"))
				{	soap_flag_RecvBytes--;
					continue;
				}
			if (soap_flag_Duplicates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "Duplicates", &a->Duplicates, "xsd:unsignedInt"))
				{	soap_flag_Duplicates--;
					continue;
				}
			if (soap_flag_Reordered && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "Reordered", &a->Reordered, "xsd:unsignedInt"))
				{	soap_flag_Reordered--;
					continue;
				}
			if (soap_flag_Corrupted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "Corrupted", &a->Corrupted, "xsd:unsignedInt"))
				{	soap_flag_Corrupted--;
					continue;
				}
			if (soap_flag_DeltaTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "DeltaTime", &a->DeltaTime, "xsd:long"))
				{	soap_flag_DeltaTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct BasicSourceStats_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_BasicSourceStats_t, 0, sizeof(struct BasicSourceStats_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_Duration > 0 || soap_flag_FinishTime > 0 || soap_flag_SentPackets > 0 || soap_flag_SentBytes > 0 || soap_flag_RecvPackets > 0 || soap_flag_RecvBytes > 0 || soap_flag_Duplicates > 0 || soap_flag_Reordered > 0 || soap_flag_Corrupted > 0 || soap_flag_DeltaTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_BasicSourceStats_t(struct soap *soap, const struct BasicSourceStats_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_BasicSourceStats_t);
	if (soap_out_BasicSourceStats_t(soap, tag?tag:"BasicSourceStats-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct BasicSourceStats_t * SOAP_FMAC4 soap_get_BasicSourceStats_t(struct soap *soap, struct BasicSourceStats_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_BasicSourceStats_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct BasicSourceStats_t * SOAP_FMAC2 soap_instantiate_BasicSourceStats_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_BasicSourceStats_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_BasicSourceStats_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct BasicSourceStats_t);
		if (size)
			*size = sizeof(struct BasicSourceStats_t);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct BasicSourceStats_t[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct BasicSourceStats_t);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct BasicSourceStats_t*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_BasicSourceStats_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct BasicSourceStats_t %p -> %p\n", q, p));
	*(struct BasicSourceStats_t*)p = *(struct BasicSourceStats_t*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_senderDesc_t(struct soap *soap, struct senderDesc_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->LocalAddr);
	soap_default_unsignedShort(soap, &a->LocalPort);
	soap_default_unsignedInt(soap, &a->RemoteAddr);
	soap_default_unsignedShort(soap, &a->RemotePort);
	soap_default_std__string(soap, &a->RemoteURL);
	soap_default_unsignedInt(soap, &a->Bytes);
	soap_default_unsignedInt(soap, &a->Packets);
	soap_default_proto_t(soap, &a->Proto);
	soap_default_tv_type(soap, &a->StartTime);
	soap_default_tv_type(soap, &a->Duration);
	soap_default_tv_type(soap, &a->FinishTime);
	soap_default_int(soap, &a->Priority);
	soap_default_SourceType(soap, &a->SType);
	soap_default_byte(soap, &a->TOS);
	soap_default_unsignedLONG64(soap, &a->BPS);
	soap_default_unsignedInt(soap, &a->Size);
	soap_default_std__string(soap, &a->FifoName);
	soap_default_bool(soap, &a->TimeCorrection);
	soap_default_unsignedLong(soap, &a->MaxTimeDev);
	soap_default_std__vectorTemplateOfsock_opt_t(soap, &a->SockOpts);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_senderDesc_t(struct soap *soap, const struct senderDesc_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->RemoteURL);
	soap_serialize_tv_type(soap, &a->StartTime);
	soap_serialize_tv_type(soap, &a->Duration);
	soap_serialize_tv_type(soap, &a->FinishTime);
	soap_embedded(soap, &a->TOS, SOAP_TYPE_byte);
	soap_serialize_std__string(soap, &a->FifoName);
	soap_serialize_std__vectorTemplateOfsock_opt_t(soap, &a->SockOpts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_senderDesc_t(struct soap *soap, const char *tag, int id, const struct senderDesc_t *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_senderDesc_t), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "LocalAddr", -1, &a->LocalAddr, ""))
		return soap->error;
	if (soap_out_unsignedShort(soap, "LocalPort", -1, &a->LocalPort, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "RemoteAddr", -1, &a->RemoteAddr, ""))
		return soap->error;
	if (soap_out_unsignedShort(soap, "RemotePort", -1, &a->RemotePort, ""))
		return soap->error;
	if (soap_out_std__string(soap, "RemoteURL", -1, &a->RemoteURL, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Bytes", -1, &a->Bytes, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Packets", -1, &a->Packets, ""))
		return soap->error;
	if (soap_out_proto_t(soap, "Proto", -1, &a->Proto, ""))
		return soap->error;
	if (soap_out_tv_type(soap, "StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_tv_type(soap, "Duration", -1, &a->Duration, ""))
		return soap->error;
	if (soap_out_tv_type(soap, "FinishTime", -1, &a->FinishTime, ""))
		return soap->error;
	if (soap_out_int(soap, "Priority", -1, &a->Priority, ""))
		return soap->error;
	if (soap_out_SourceType(soap, "SType", -1, &a->SType, ""))
		return soap->error;
	if (soap_out_byte(soap, "TOS", -1, &a->TOS, ""))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "BPS", -1, &a->BPS, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "Size", -1, &a->Size, ""))
		return soap->error;
	if (soap_out_std__string(soap, "FifoName", -1, &a->FifoName, ""))
		return soap->error;
	if (soap_out_bool(soap, "TimeCorrection", -1, &a->TimeCorrection, ""))
		return soap->error;
	if (soap_out_unsignedLong(soap, "MaxTimeDev", -1, &a->MaxTimeDev, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsock_opt_t(soap, "SockOpts", -1, &a->SockOpts, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct senderDesc_t * SOAP_FMAC4 soap_in_senderDesc_t(struct soap *soap, const char *tag, struct senderDesc_t *a, const char *type)
{
	size_t soap_flag_LocalAddr = 1;
	size_t soap_flag_LocalPort = 1;
	size_t soap_flag_RemoteAddr = 1;
	size_t soap_flag_RemotePort = 1;
	size_t soap_flag_RemoteURL = 1;
	size_t soap_flag_Bytes = 1;
	size_t soap_flag_Packets = 1;
	size_t soap_flag_Proto = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_Duration = 1;
	size_t soap_flag_FinishTime = 1;
	size_t soap_flag_Priority = 1;
	size_t soap_flag_SType = 1;
	size_t soap_flag_TOS = 1;
	size_t soap_flag_BPS = 1;
	size_t soap_flag_Size = 1;
	size_t soap_flag_FifoName = 1;
	size_t soap_flag_TimeCorrection = 1;
	size_t soap_flag_MaxTimeDev = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct senderDesc_t *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_senderDesc_t, sizeof(struct senderDesc_t), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_senderDesc_t(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LocalAddr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "LocalAddr", &a->LocalAddr, "xsd:unsignedInt"))
				{	soap_flag_LocalAddr--;
					continue;
				}
			if (soap_flag_LocalPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedShort(soap, "LocalPort", &a->LocalPort, "xsd:unsignedShort"))
				{	soap_flag_LocalPort--;
					continue;
				}
			if (soap_flag_RemoteAddr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "RemoteAddr", &a->RemoteAddr, "xsd:unsignedInt"))
				{	soap_flag_RemoteAddr--;
					continue;
				}
			if (soap_flag_RemotePort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedShort(soap, "RemotePort", &a->RemotePort, "xsd:unsignedShort"))
				{	soap_flag_RemotePort--;
					continue;
				}
			if (soap_flag_RemoteURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "RemoteURL", &a->RemoteURL, "xsd:string"))
				{	soap_flag_RemoteURL--;
					continue;
				}
			if (soap_flag_Bytes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "Bytes", &a->Bytes, "xsd:unsignedInt"))
				{	soap_flag_Bytes--;
					continue;
				}
			if (soap_flag_Packets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "Packets", &a->Packets, "xsd:unsignedInt"))
				{	soap_flag_Packets--;
					continue;
				}
			if (soap_flag_Proto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_proto_t(soap, "Proto", &a->Proto, "proto-t"))
				{	soap_flag_Proto--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "StartTime", &a->StartTime, "tv-type"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_Duration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "Duration", &a->Duration, "tv-type"))
				{	soap_flag_Duration--;
					continue;
				}
			if (soap_flag_FinishTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "FinishTime", &a->FinishTime, "tv-type"))
				{	soap_flag_FinishTime--;
					continue;
				}
			if (soap_flag_Priority && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Priority", &a->Priority, "xsd:int"))
				{	soap_flag_Priority--;
					continue;
				}
			if (soap_flag_SType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_SourceType(soap, "SType", &a->SType, "SourceType"))
				{	soap_flag_SType--;
					continue;
				}
			if (soap_flag_TOS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_byte(soap, "TOS", &a->TOS, "xsd:byte"))
				{	soap_flag_TOS--;
					continue;
				}
			if (soap_flag_BPS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "BPS", &a->BPS, "xsd:unsignedLong"))
				{	soap_flag_BPS--;
					continue;
				}
			if (soap_flag_Size && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "Size", &a->Size, "xsd:unsignedInt"))
				{	soap_flag_Size--;
					continue;
				}
			if (soap_flag_FifoName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FifoName", &a->FifoName, "xsd:string"))
				{	soap_flag_FifoName--;
					continue;
				}
			if (soap_flag_TimeCorrection && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "TimeCorrection", &a->TimeCorrection, "xsd:boolean"))
				{	soap_flag_TimeCorrection--;
					continue;
				}
			if (soap_flag_MaxTimeDev && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLong(soap, "MaxTimeDev", &a->MaxTimeDev, "xsd:unsignedLong"))
				{	soap_flag_MaxTimeDev--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfsock_opt_t(soap, "SockOpts", &a->SockOpts, "sock-opt-t"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct senderDesc_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_senderDesc_t, 0, sizeof(struct senderDesc_t), 0, soap_copy_senderDesc_t);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LocalAddr > 0 || soap_flag_LocalPort > 0 || soap_flag_RemoteAddr > 0 || soap_flag_RemotePort > 0 || soap_flag_RemoteURL > 0 || soap_flag_Bytes > 0 || soap_flag_Packets > 0 || soap_flag_Proto > 0 || soap_flag_StartTime > 0 || soap_flag_Duration > 0 || soap_flag_FinishTime > 0 || soap_flag_Priority > 0 || soap_flag_SType > 0 || soap_flag_TOS > 0 || soap_flag_BPS > 0 || soap_flag_Size > 0 || soap_flag_FifoName > 0 || soap_flag_TimeCorrection > 0 || soap_flag_MaxTimeDev > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_senderDesc_t(struct soap *soap, const struct senderDesc_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_senderDesc_t);
	if (soap_out_senderDesc_t(soap, tag?tag:"senderDesc-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct senderDesc_t * SOAP_FMAC4 soap_get_senderDesc_t(struct soap *soap, struct senderDesc_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_senderDesc_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct senderDesc_t * SOAP_FMAC2 soap_instantiate_senderDesc_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_senderDesc_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_senderDesc_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct senderDesc_t);
		if (size)
			*size = sizeof(struct senderDesc_t);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct senderDesc_t[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct senderDesc_t);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct senderDesc_t*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_senderDesc_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct senderDesc_t %p -> %p\n", q, p));
	*(struct senderDesc_t*)p = *(struct senderDesc_t*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sourceDesc_t(struct soap *soap, struct sourceDesc_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tv_type(soap, &a->StartTime);
	soap_default_tv_type(soap, &a->StopTime);
	soap_default_unsignedInt(soap, &a->sample_n);
	soap_default_unsignedInt(soap, &a->maxPDUSize);
	soap_default_unsignedInt(soap, &a->ListenAddr);
	soap_default_unsignedShort(soap, &a->ListenPort);
	soap_default_proto_t(soap, &a->Proto);
	soap_default_int(soap, &a->Prio);
	soap_default_byte(soap, &a->TOS);
	soap_default_bool(soap, &a->Block);
	soap_default_std__vectorTemplateOfsock_opt_t(soap, &a->SockOpts);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sourceDesc_t(struct soap *soap, const struct sourceDesc_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tv_type(soap, &a->StartTime);
	soap_serialize_tv_type(soap, &a->StopTime);
	soap_embedded(soap, &a->TOS, SOAP_TYPE_byte);
	soap_serialize_std__vectorTemplateOfsock_opt_t(soap, &a->SockOpts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sourceDesc_t(struct soap *soap, const char *tag, int id, const struct sourceDesc_t *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sourceDesc_t), type))
		return soap->error;
	if (soap_out_tv_type(soap, "StartTime", -1, &a->StartTime, ""))
		return soap->error;
	if (soap_out_tv_type(soap, "StopTime", -1, &a->StopTime, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "sample-n", -1, &a->sample_n, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "maxPDUSize", -1, &a->maxPDUSize, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "ListenAddr", -1, &a->ListenAddr, ""))
		return soap->error;
	if (soap_out_unsignedShort(soap, "ListenPort", -1, &a->ListenPort, ""))
		return soap->error;
	if (soap_out_proto_t(soap, "Proto", -1, &a->Proto, ""))
		return soap->error;
	if (soap_out_int(soap, "Prio", -1, &a->Prio, ""))
		return soap->error;
	if (soap_out_byte(soap, "TOS", -1, &a->TOS, ""))
		return soap->error;
	if (soap_out_bool(soap, "Block", -1, &a->Block, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfsock_opt_t(soap, "SockOpts", -1, &a->SockOpts, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sourceDesc_t * SOAP_FMAC4 soap_in_sourceDesc_t(struct soap *soap, const char *tag, struct sourceDesc_t *a, const char *type)
{
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_StopTime = 1;
	size_t soap_flag_sample_n = 1;
	size_t soap_flag_maxPDUSize = 1;
	size_t soap_flag_ListenAddr = 1;
	size_t soap_flag_ListenPort = 1;
	size_t soap_flag_Proto = 1;
	size_t soap_flag_Prio = 1;
	size_t soap_flag_TOS = 1;
	size_t soap_flag_Block = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sourceDesc_t *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_sourceDesc_t, sizeof(struct sourceDesc_t), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_sourceDesc_t(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "StartTime", &a->StartTime, "tv-type"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_StopTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tv_type(soap, "StopTime", &a->StopTime, "tv-type"))
				{	soap_flag_StopTime--;
					continue;
				}
			if (soap_flag_sample_n && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "sample-n", &a->sample_n, "xsd:unsignedInt"))
				{	soap_flag_sample_n--;
					continue;
				}
			if (soap_flag_maxPDUSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "maxPDUSize", &a->maxPDUSize, "xsd:unsignedInt"))
				{	soap_flag_maxPDUSize--;
					continue;
				}
			if (soap_flag_ListenAddr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "ListenAddr", &a->ListenAddr, "xsd:unsignedInt"))
				{	soap_flag_ListenAddr--;
					continue;
				}
			if (soap_flag_ListenPort && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedShort(soap, "ListenPort", &a->ListenPort, "xsd:unsignedShort"))
				{	soap_flag_ListenPort--;
					continue;
				}
			if (soap_flag_Proto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_proto_t(soap, "Proto", &a->Proto, "proto-t"))
				{	soap_flag_Proto--;
					continue;
				}
			if (soap_flag_Prio && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Prio", &a->Prio, "xsd:int"))
				{	soap_flag_Prio--;
					continue;
				}
			if (soap_flag_TOS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_byte(soap, "TOS", &a->TOS, "xsd:byte"))
				{	soap_flag_TOS--;
					continue;
				}
			if (soap_flag_Block && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "Block", &a->Block, "xsd:boolean"))
				{	soap_flag_Block--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfsock_opt_t(soap, "SockOpts", &a->SockOpts, "sock-opt-t"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sourceDesc_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sourceDesc_t, 0, sizeof(struct sourceDesc_t), 0, soap_copy_sourceDesc_t);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime > 0 || soap_flag_StopTime > 0 || soap_flag_sample_n > 0 || soap_flag_maxPDUSize > 0 || soap_flag_ListenAddr > 0 || soap_flag_ListenPort > 0 || soap_flag_Proto > 0 || soap_flag_Prio > 0 || soap_flag_TOS > 0 || soap_flag_Block > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sourceDesc_t(struct soap *soap, const struct sourceDesc_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sourceDesc_t);
	if (soap_out_sourceDesc_t(soap, tag?tag:"sourceDesc-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct sourceDesc_t * SOAP_FMAC4 soap_get_sourceDesc_t(struct soap *soap, struct sourceDesc_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_sourceDesc_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct sourceDesc_t * SOAP_FMAC2 soap_instantiate_sourceDesc_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_sourceDesc_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_sourceDesc_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct sourceDesc_t);
		if (size)
			*size = sizeof(struct sourceDesc_t);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct sourceDesc_t[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct sourceDesc_t);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct sourceDesc_t*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_sourceDesc_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct sourceDesc_t %p -> %p\n", q, p));
	*(struct sourceDesc_t*)p = *(struct sourceDesc_t*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_whole_sample_t(struct soap *soap, struct whole_sample_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_Array24Ofbyte(soap, a->Header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_whole_sample_t(struct soap *soap, const struct whole_sample_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array24Ofbyte(soap, a->Header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_whole_sample_t(struct soap *soap, const char *tag, int id, const struct whole_sample_t *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_whole_sample_t), type))
		return soap->error;
	soap_out_Array24Ofbyte(soap, "Header", -1, a->Header, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct whole_sample_t * SOAP_FMAC4 soap_in_whole_sample_t(struct soap *soap, const char *tag, struct whole_sample_t *a, const char *type)
{
	size_t soap_flag_Header = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct whole_sample_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_whole_sample_t, sizeof(struct whole_sample_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_whole_sample_t(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Header && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array24Ofbyte(soap, "Header", a->Header, "xsd:byte"))
				{	soap_flag_Header--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct whole_sample_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_whole_sample_t, 0, sizeof(struct whole_sample_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Header > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_whole_sample_t(struct soap *soap, const struct whole_sample_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_whole_sample_t);
	if (soap_out_whole_sample_t(soap, tag?tag:"whole-sample-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct whole_sample_t * SOAP_FMAC4 soap_get_whole_sample_t(struct soap *soap, struct whole_sample_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_whole_sample_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct whole_sample_t * SOAP_FMAC2 soap_instantiate_whole_sample_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_whole_sample_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_whole_sample_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct whole_sample_t);
		if (size)
			*size = sizeof(struct whole_sample_t);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct whole_sample_t[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct whole_sample_t);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct whole_sample_t*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_whole_sample_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct whole_sample_t %p -> %p\n", q, p));
	*(struct whole_sample_t*)p = *(struct whole_sample_t*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sock_opt_t(struct soap *soap, struct sock_opt_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->key);
	soap_default_unsignedInt(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sock_opt_t(struct soap *soap, const struct sock_opt_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sock_opt_t(struct soap *soap, const char *tag, int id, const struct sock_opt_t *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sock_opt_t), type))
		return soap->error;
	if (soap_out_std__string(soap, "key", -1, &a->key, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sock_opt_t * SOAP_FMAC4 soap_in_sock_opt_t(struct soap *soap, const char *tag, struct sock_opt_t *a, const char *type)
{
	size_t soap_flag_key = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sock_opt_t *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_sock_opt_t, sizeof(struct sock_opt_t), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_sock_opt_t(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "key", &a->key, "xsd:string"))
				{	soap_flag_key--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "value", &a->value, "xsd:unsignedInt"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sock_opt_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sock_opt_t, 0, sizeof(struct sock_opt_t), 0, soap_copy_sock_opt_t);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_key > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sock_opt_t(struct soap *soap, const struct sock_opt_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sock_opt_t);
	if (soap_out_sock_opt_t(soap, tag?tag:"sock-opt-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct sock_opt_t * SOAP_FMAC4 soap_get_sock_opt_t(struct soap *soap, struct sock_opt_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_sock_opt_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct sock_opt_t * SOAP_FMAC2 soap_instantiate_sock_opt_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_sock_opt_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_sock_opt_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct sock_opt_t);
		if (size)
			*size = sizeof(struct sock_opt_t);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct sock_opt_t[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct sock_opt_t);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct sock_opt_t*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_sock_opt_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct sock_opt_t %p -> %p\n", q, p));
	*(struct sock_opt_t*)p = *(struct sock_opt_t*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_sample_t(struct soap *soap, struct sample_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_Array12Ofbyte(soap, a->Header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_sample_t(struct soap *soap, const struct sample_t *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_Array12Ofbyte(soap, a->Header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sample_t(struct soap *soap, const char *tag, int id, const struct sample_t *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_sample_t), type))
		return soap->error;
	soap_out_Array12Ofbyte(soap, "Header", -1, a->Header, "");
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct sample_t * SOAP_FMAC4 soap_in_sample_t(struct soap *soap, const char *tag, struct sample_t *a, const char *type)
{
	size_t soap_flag_Header = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct sample_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sample_t, sizeof(struct sample_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_sample_t(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Header && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Array12Ofbyte(soap, "Header", a->Header, "xsd:byte"))
				{	soap_flag_Header--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct sample_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sample_t, 0, sizeof(struct sample_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Header > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_sample_t(struct soap *soap, const struct sample_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_sample_t);
	if (soap_out_sample_t(soap, tag?tag:"sample-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct sample_t * SOAP_FMAC4 soap_get_sample_t(struct soap *soap, struct sample_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_sample_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct sample_t * SOAP_FMAC2 soap_instantiate_sample_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_sample_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_sample_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct sample_t);
		if (size)
			*size = sizeof(struct sample_t);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct sample_t[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct sample_t);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct sample_t*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_sample_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct sample_t %p -> %p\n", q, p));
	*(struct sample_t*)p = *(struct sample_t*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tv_type(struct soap *soap, struct tv_type *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->tv_sec);
	soap_default_unsignedInt(soap, &a->tv_usec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tv_type(struct soap *soap, const struct tv_type *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tv_type(struct soap *soap, const char *tag, int id, const struct tv_type *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tv_type), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "tv-sec", -1, &a->tv_sec, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "tv-usec", -1, &a->tv_usec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tv_type * SOAP_FMAC4 soap_in_tv_type(struct soap *soap, const char *tag, struct tv_type *a, const char *type)
{
	size_t soap_flag_tv_sec = 1;
	size_t soap_flag_tv_usec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tv_type *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tv_type, sizeof(struct tv_type), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tv_type(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tv_sec && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "tv-sec", &a->tv_sec, "xsd:unsignedInt"))
				{	soap_flag_tv_sec--;
					continue;
				}
			if (soap_flag_tv_usec && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "tv-usec", &a->tv_usec, "xsd:unsignedInt"))
				{	soap_flag_tv_usec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tv_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tv_type, 0, sizeof(struct tv_type), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tv_sec > 0 || soap_flag_tv_usec > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tv_type(struct soap *soap, const struct tv_type *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tv_type);
	if (soap_out_tv_type(soap, tag?tag:"tv-type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tv_type * SOAP_FMAC4 soap_get_tv_type(struct soap *soap, struct tv_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_tv_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct tv_type * SOAP_FMAC2 soap_instantiate_tv_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tv_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tv_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct tv_type);
		if (size)
			*size = sizeof(struct tv_type);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct tv_type[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct tv_type);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct tv_type*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tv_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct tv_type %p -> %p\n", q, p));
	*(struct tv_type*)p = *(struct tv_type*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Reason *)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Detail *)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Code *)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array24Ofbyte(struct soap *soap, char a[24])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 24; i++)
	soap_default_byte(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array24Ofbyte(struct soap *soap, char const a[24])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array24Ofbyte(struct soap *soap, const char *tag, int id, char const a[24], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array24Ofbyte), "xsd:byte[24]", 0);
	for (i = 0; i < 24; i++)
	{
		soap_out_byte(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_Array24Ofbyte(struct soap *soap, const char *tag, char a[24], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (char (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array24Ofbyte, sizeof(char[24]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array24Ofbyte(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 24; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 24)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_byte(soap, NULL, a+i, "xsd:byte"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (char (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array24Ofbyte, sizeof(char[24]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array24Ofbyte, 0, sizeof(char[24]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (char *)a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array24Ofbyte(struct soap *soap, char const a[24], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array24Ofbyte);
	if (soap_out_Array24Ofbyte(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_Array24Ofbyte(struct soap *soap, char a[24], const char *tag, const char *type)
{	char (*p);
	if ((p = soap_in_Array24Ofbyte(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Array12Ofbyte(struct soap *soap, char a[12])
{
	int i;
	(void)soap; /* appease -Wall -Werror */
	for (i = 0; i < 12; i++)
	soap_default_byte(soap, a+i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_Array12Ofbyte(struct soap *soap, char const a[12])
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Array12Ofbyte(struct soap *soap, const char *tag, int id, char const a[12], const char *type)
{
	int i;
	soap_array_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Array12Ofbyte), "xsd:byte[12]", 0);
	for (i = 0; i < 12; i++)
	{
		soap_out_byte(soap, "item", -1, a+i, "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_Array12Ofbyte(struct soap *soap, const char *tag, char a[12], const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (char (*))soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array12Ofbyte, sizeof(char[12]), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_Array12Ofbyte(soap, a);
	if (soap->body && !*soap->href)
	{	int i;
		for (i = 0; i < 12; i++)
		{	soap_peek_element(soap);
			if (soap->position)
			{	i = soap->positions[0];
				if (i < 0 || i >= 12)
				{	soap->error = SOAP_IOB;
					return NULL;
				}
			}
			if (!soap_in_byte(soap, NULL, a+i, "xsd:byte"))
			{	if (soap->error != SOAP_NO_TAG)
					return NULL;
				soap->error = SOAP_OK;
				break;
			}
		}
		if (soap->mode & SOAP_C_NOIOB)
			while (soap_element_end_in(soap, tag) == SOAP_SYNTAX_ERROR)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		else if (soap_element_end_in(soap, tag))
		{	if (soap->error == SOAP_SYNTAX_ERROR)
				soap->error = SOAP_IOB;
			return NULL;
		}
	}
	else
	{	a = (char (*))soap_id_forward(soap, soap->href, (void*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Array12Ofbyte, sizeof(char[12]), 0, NULL, NULL, NULL), 0, SOAP_TYPE_Array12Ofbyte, 0, sizeof(char[12]), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return (char *)a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Array12Ofbyte(struct soap *soap, char const a[12], const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Array12Ofbyte);
	if (soap_out_Array12Ofbyte(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_Array12Ofbyte(struct soap *soap, char a[12], const char *tag, const char *type)
{	char (*p);
	if ((p = soap_in_Array12Ofbyte(soap, tag, a, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsample_t(struct soap *soap, std::vector<struct sample_t >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsample_t(struct soap *soap, const std::vector<struct sample_t >*a)
{
	for (std::vector<struct sample_t >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_sample_t(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsample_t(struct soap *soap, const char *tag, int id, const std::vector<struct sample_t >*a, const char *type)
{
	for (std::vector<struct sample_t >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_sample_t(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct sample_t >* SOAP_FMAC4 soap_in_std__vectorTemplateOfsample_t(struct soap *soap, const char *tag, std::vector<struct sample_t >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfsample_t(soap, -1)))
		return NULL;
	struct sample_t n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_sample_t(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_sample_t, SOAP_TYPE_std__vectorTemplateOfsample_t, sizeof(struct sample_t), 0))
				break;
			if (!soap_in_sample_t(soap, tag, NULL, "sample-t"))
				break;
		}
		else
		{
			if (!soap_in_sample_t(soap, tag, &n, "sample-t"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct sample_t > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfsample_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfsample_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfsample_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct sample_t >);
		if (size)
			*size = sizeof(std::vector<struct sample_t >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct sample_t >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<struct sample_t >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<struct sample_t >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfsample_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<struct sample_t > %p -> %p\n", q, p));
	*(std::vector<struct sample_t >*)p = *(std::vector<struct sample_t >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwhole_sample_t(struct soap *soap, std::vector<struct whole_sample_t >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwhole_sample_t(struct soap *soap, const std::vector<struct whole_sample_t >*a)
{
	for (std::vector<struct whole_sample_t >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_whole_sample_t(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwhole_sample_t(struct soap *soap, const char *tag, int id, const std::vector<struct whole_sample_t >*a, const char *type)
{
	for (std::vector<struct whole_sample_t >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_whole_sample_t(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct whole_sample_t >* SOAP_FMAC4 soap_in_std__vectorTemplateOfwhole_sample_t(struct soap *soap, const char *tag, std::vector<struct whole_sample_t >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfwhole_sample_t(soap, -1)))
		return NULL;
	struct whole_sample_t n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_whole_sample_t(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_whole_sample_t, SOAP_TYPE_std__vectorTemplateOfwhole_sample_t, sizeof(struct whole_sample_t), 0))
				break;
			if (!soap_in_whole_sample_t(soap, tag, NULL, "whole-sample-t"))
				break;
		}
		else
		{
			if (!soap_in_whole_sample_t(soap, tag, &n, "whole-sample-t"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct whole_sample_t > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfwhole_sample_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfwhole_sample_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfwhole_sample_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct whole_sample_t >);
		if (size)
			*size = sizeof(std::vector<struct whole_sample_t >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct whole_sample_t >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<struct whole_sample_t >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<struct whole_sample_t >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfwhole_sample_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<struct whole_sample_t > %p -> %p\n", q, p));
	*(std::vector<struct whole_sample_t >*)p = *(std::vector<struct whole_sample_t >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfsock_opt_t(struct soap *soap, std::vector<struct sock_opt_t >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfsock_opt_t(struct soap *soap, const std::vector<struct sock_opt_t >*a)
{
	for (std::vector<struct sock_opt_t >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_sock_opt_t(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfsock_opt_t(struct soap *soap, const char *tag, int id, const std::vector<struct sock_opt_t >*a, const char *type)
{
	for (std::vector<struct sock_opt_t >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_sock_opt_t(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct sock_opt_t >* SOAP_FMAC4 soap_in_std__vectorTemplateOfsock_opt_t(struct soap *soap, const char *tag, std::vector<struct sock_opt_t >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfsock_opt_t(soap, -1)))
		return NULL;
	struct sock_opt_t n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		soap_default_sock_opt_t(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_sock_opt_t, SOAP_TYPE_std__vectorTemplateOfsock_opt_t, sizeof(struct sock_opt_t), 0))
				break;
			if (!soap_in_sock_opt_t(soap, tag, NULL, "sock-opt-t"))
				break;
		}
		else
		{
			if (!soap_in_sock_opt_t(soap, tag, &n, "sock-opt-t"))
				break;
		}
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct sock_opt_t > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfsock_opt_t(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfsock_opt_t(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfsock_opt_t, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct sock_opt_t >);
		if (size)
			*size = sizeof(std::vector<struct sock_opt_t >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<struct sock_opt_t >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<struct sock_opt_t >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<struct sock_opt_t >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfsock_opt_t(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<struct sock_opt_t > %p -> %p\n", q, p));
	*(std::vector<struct sock_opt_t >*)p = *(std::vector<struct sock_opt_t >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
